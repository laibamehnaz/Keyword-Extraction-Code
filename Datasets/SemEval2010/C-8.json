{"Operation Context and Context-based Operational\nTransformation\nDavid Sun\nComputer Science Division, EECS\nUniversity of California\nBerkeley, CA\ndavidsun@cs.berkeley.edu\nChengzheng Sun\nSchool of Computer Engineering\nNanyang Technological University\nSingapore\nCZSun@ntu.edu.sg\nABSTRACT\nOperational Transformation (OT) is a technique for \nconsistency maintenance and group undo, and is being applied\nto an increasing number of collaborative applications. The\ntheoretical foundation for OT is crucial in determining its\ncapability to solve existing and new problems, as well as\nthe quality of those solutions. The theory of causality has\nbeen the foundation of all prior OT systems, but it is \ninadequate to capture essential correctness requirements. Past\nresearch had invented various patches to work around this\nproblem, resulting in increasingly intricate and complicated\nOT algorithms. After having designed, implemented, and\nexperimented with a series of OT algorithms, we reflected\non what had been learned and set out to develop a new \ntheoretical framework for better understanding and resolving\nOT problems, reducing its complexity, and supporting its\ncontinual evolution. In this paper, we report the main \nresults of this effort: the theory of operation context and the\nCOT (Context-based OT) algorithm. The COT algorithm\nis capable of supporting both do and undo of any \noperations at anytime, without requiring transformation functions\nto preserve Reversibility Property, Convergence Property 2,\nInverse Properties 2 and 3. The COT algorithm is not only\nsimpler and more efficient than prior OT control algorithms,\nbut also simplifies the design of transformation functions.\nWe have implemented the COT algorithm in a generic \ncollaboration engine and used it for supporting a range of novel\ncollaborative applications.\nCategories and Subject Descriptors\nC.2.4 [Computer-Communication Networks]: \nDistributed Systems-Distributed Applications; H.5.3 [Information\nInterfaces and Presentation]: Group and Organization\nInterfaces-Collaborative computing; Synchronous \ninteraction\nGeneral Terms\nAlgorithms, Design, Theory\n1. INTRODUCTION\nOperational Transformation (OT) was originally invented\nfor consistency maintenance in plain-text group editors [4].\nIn over 15 years, OT has evolved to support an increasing\nnumber of applications, including group undo [15, 19, 18,\n21], group-awareness [28], operation notification and \ncompression [20], spreadsheet and table-centric applications [14,\n27], HTML/XML and tree-structured document editing [3,\n7], word processing and slide creation [29, 25, 24], \ntransparent and heterogenous application-sharing [1, 10, 24], and\nmobile replicated computing and database systems [6, 16].\nTo effectively and efficiently support existing and new \napplications, we must continue to improve the capability and\nquality of OT in solving both old and new problems. The\nsoundness of the theoretical foundation for OT is crucial in\nthis process. One theoretical underpinning of all existing OT\nalgorithms is causality/concurrency [9, 17, 4, 22]: causally\nrelated operations must be executed in their causal order;\nconcurrent operations must be transformed before their \nexecution. However, the theory of causality is inadequate to\ncapture essential OT conditions for correct transformation.\nThe limitation of the causality theory had caused \ncorrectness problems from the very beginning of OT. The dOPT\nalgorithm was the first OT algorithm and was based solely\non the concurrency relationships among operations [4]: a\npair of operations are transformable as long as they are \nconcurrent. However, later research discovered that the \nconcurrency condition alone is not sufficient to ensure the \ncorrectness of transformation. Another condition is that the two\nconcurrent operations must be defined on the same \ndocument state. In fact, the failure to meet the second \ncondition was the root of the dOPT-puzzle [22]. This puzzle was\nsolved in various ways, but the theory of causality as well as\nits limitation were inherited by all follow-up OT algorithms.\nThe causality theory limitation became even more \nprominent when OT was applied to solve the undo problem in\ngroup editors. The concept of causality is unsuitable to\ncapture the relationships between an inverse operation (as\nan interpretation of a meta-level undo command) and other\nnormal editing operations. In fact, the causality relation is\nnot defined for inverse operations (see Section 2). Various\npatches were invented to work around this problem, \nresulting in more intricate complicated OT algorithms [18, 21].\nAfter having designed, implemented, and experimented\nwith a series of OT algorithms of increased complexity, we\nreflected on what had been learned and set out to develop\na uniformed theoretical framework for better understanding\nand resolving OT problems, reducing its complexity, and\n279\nsupporting its continual evolution. In this paper, we report\nthe main results of this effort: the theory of operation \ncontext and the COT (Context-based OT) algorithm.\nThe rest of this paper is organized as follows. First, we \ndefine causal-dependency/-independency and briefly describe\ntheir limitations in Section 2. Then, we present the key \nelements of the operation context theory, including the \ndefinition of operation context, context-dependency/-independency\nrelations, context-based conditions, and context vectors in\nSection 3. In Section 4, we present the basic COT \nalgorithm for supporting consistency maintenance (do) and\ngroup undo under the assumption that underlying \ntransformation functions are able to preserve some important \ntransformation properties. Then, these transformation properties\nand their pre-conditions are discussed in Section 5. The\nCOT solutions to these transformation properties are \npresented in Section 6. Comparison of the COT work to prior\nOT work, OT correctness issues, and future work are \ndiscussed in Section 7. Finally, major contributions of this\nwork are summarized in Section 8.\n2. LIMITATIONS OF CAUSALITY\nThe theory of causality is central to distributed \ncomputing and to the design of all existing OT algorithms. \nFollowing Lamport [9], causal-dependency/-independency \nrelations among editing operations can be defined in terms of\ntheir generation and execution sequences [4, 23].\nDefinition 1. Causal-dependency relation \u00e2\u2020\u2019\nGiven two operations Oa and Ob, generated at sites i and\nj, Ob is causal-dependent on Oa, denoted by Oa \u00e2\u2020\u2019 Ob, iff:\n(1) i = j and the generation of Oa happened before the \ngeneration of Ob; or (2) i = j and the execution of Oa at site j\nhappened before the generation of Ob; or (3) there exists an\noperation Ox, such that Oa \u00e2\u2020\u2019 Ox and Ox \u00e2\u2020\u2019 Ob. 2\nDefinition 2. Causal-independency relation  \nGiven two operations Oa and Ob, Oa and Ob are \ncausalindependent or concurrent, denoted by Oa Ob, iff neither\nOa \u00e2\u2020\u2019 Ob, nor Ob \u00e2\u2020\u2019 Oa. 2\nJust as Vector Logical Clocks are used for capturing \ncasuality in distributed systems [17], State Vectors have been\nused for capturing causal relationships among operations\nand for representing document states in OT systems [4, 19,\n23].\nTo illustrate causal relations among operations, consider\na real-time group editing session with two sites in Figure 1.\nThere are three editing operations in this scenario (the undo\ncommand Undo(O2) and its relation with other operations\nshall be explained later): O1 generated at site 0, and O2 and\nO3 generated at site 1. According to Definitions 1 and 2,\nwe have O2 \u00e2\u2020\u2019 O3 because the generation of O2 happened\nbefore the generation of O3; O1 O2 and O1 O3 because\nfor each pair, neither operation\"s execution happened before\nthe other operation\"s generation.\nIn the following discussion, we shall use the term \nITtransform to mean the use of the IT (Inclusion \nTransformation) function: IT(Oa, Ob), which transforms operation\nOa against operation Ob in such a way that the impact of Ob\nis effectively included in Oa [23]. This term is introduced to\ndifferentiate this special transformation function from other\nsteps involved in a transformation process.\nFigure 1: A real-time group editing scenario.\nThe scenario in Figure 1 (without the undo command) has\noften been used to illustrate the dOPT-puzzle. Under the\ndOPT algorithm [4], when O2 arrives at site 0, it will be \nITtransformed against O1 since O2 O1; this is correct because\nO2 and O1 are defined on the same (initial) document state.\nWhen O3 arrives at site 0, it will also be IT-transformed\nagainst O1 since O3 O1; but this is incorrect because O3 is\ndefined on the document state that contains the effect of O2,\nwhereas O1 is defined on the initial document state. In this\ncase, the parameters of O3 and O1 are not comparable and\nhence may not be IT-transformed correctly. The solution to\nthis puzzle is first to IT-transform O1 against O2 to produce\nO1, which is defined on the document state including the\neffect of O2 (the same state on which O3 is defined), and\nthen to IT-transform O3 against O1 [22].\nFrom Definitions 1 and 2, it is clear that the \ncausaldependency relation is only defined for original operations\n(e.g. O1, O2 and O3) directly generated by users, but not for\ntransformed operations (e.g. O1). Furthermore, the \nconcurrency relation does not capture the essential condition for\ncorrect IT-transformation: the two input operations must\nbe defined on the same document state [23].\nAnother major limitation of causality is its unsuitability\nfor capturing OT conditions for inverse operations. The\nUndo(O2) command in Figure 1 is interpreted as an inverse\noperation O2. The correct undo effect for O2 is to eliminate\nthe effect of O2 but retain the effects of other operations\n(i.e. O1 and O3) [21]. To achieve this effect, O2 needs to\nbe treated as an operation defined on the document state\nincluding the effect of O2 but not O1 and O3, so that O2\ncan be transformed against O1 and O3 before its execution.\nHowever, according to Lamport\"s happen-before relation [9],\nUndo(O2) is causally dependent on O1, O2, and O3. If O2\nwas to inherit the causal relation of Undo(O2), then it would\nbe effectively treated as an operation defined on the \ndocument state with the effects of all three operations O1, O2,\nand O3, which would prohibit O2 from being transformed\nagainst any operation, thus failing to achieve the correct\nundo effect. Moreover, after executing an inverse \noperation like O2, the document state can no longer be properly\nrepresented by the state vector, which is only capable of\nrepresenting original normal editing operations.\n3. OPERATION CONTEXT\n3.1 Basic concept\nConceptually, each operation O is associated with a \ncontext, denoted by C(O), which corresponds to the document\n280\nstate on which the operation is defined. The significance of\noperation context is twofold: (1) an operation can be \ncorrectly executed only if its context and the current document\nstate are the same; and (2) an operation can be correctly \nITtransformed against another operation only if the contexts\nof these two operations are the same.\nIn Figure 1, both O1 and O2 are defined on the same \ninitial document so they are associated with the same context;\nO3 is defined on the document state which includes the effect\nof O2, so C(O3) is different from C(O1) or C(O2). When\nO2 arrives at site 0, it cannot be executed as-is since C(O2)\ndoes not match the current document state at site 0 which\nincludes the effect of O1. O2 can be correctly IT-transformed\nagainst O1 since their contexts corresponds to the same \ninitial document state. When O3 arrives at site 0, it cannot be\nexecuted as-is either since C(O3) does not match the current\ndocument state at site 0 which includes the effects of both\nO1 and O2. O3 cannot be correctly IT-transformed against\nO1 since their contexts are different, which is the root of the\ndOPT-puzzle. As discussed in Section 2, Undo(O2) should\nbe interpreted as an inverse O2 defined on the document\nstate with the effect of O2 only.\n3.2 Set representation of operation context\nTo facilitate comparison and manipulation of operation\ncontexts for correct execution and transformation, it is \nnecessary to explicitly represent operation context.\nIn OT systems, there are two different kinds of operation:\noriginal operations which are generated by users, and \ntransformed operations which are the outcomes of some \ntransformations. Original operations can be further divided into\ntwo classes: normal operations which are generated to do\nsomething, and inverse operations which are generated to\nundo some executed operations. For any operation O, its\ninverse is denoted by O. Since every transformed operation\nmust come from an original operation, we use the notation\norg(O) to denote the original operation of O. If O is an\noriginal operation, then org(O) = O.\nSince the context of an operation corresponds to the \ndocument state on which the operation is defined, the problem\nof context representation can be reduced into the problem\nof document state representation. In an OT-based group\neditor, each document state can be uniquely represented by\nthe set of original operations executed so far on the \ndocument. These original operations may be executed in different\norders or in different (original or transformed) forms at \ndifferent sites, but the same document state must be achieved\n(according to the convergence requirement [23]). We use\noriginal (normal and inverse) operations, rather than their\ntransformed versions, to represent a document state.\nDefinition 3. Document state representation\nA document state can be represented by DS as follows:\n1. The initial document state is represented by DS = {}.\n2. After executing an operation O of any type on the\ndocument state represented by DS, the new document\nstate is represented by DS = DS \u00e2\u02c6\u00aa {org(O)}. 2\nThis presentation does not specify what execution forms\nthe original operations in DS should take to bring the \ndocument to the current state, but it captures essential and\nsufficient information for detecting whether two document\nstates are the same and for deriving their differences in terms\nof original operations.\nBased on the document state representation, the context\nof an original normal operation should be the same as the\nrepresentation of the document state from which this \noperation was generated. To achieve the undo effect in [21],\nan original inverse operation O should be defined on the\ndocument state DS = C(O) \u00e2\u02c6\u00aa {O}, which is the state \nafter executing the original operation O on the state C(O).\nAccording to the definition of the IT function [23], a \ntransformed operation O , where O = IT(O, Ox), should be \ndefined on the document state DS = C(O)\u00e2\u02c6\u00aa{org(Ox)}, which\nis the state achievable by executing Ox on the state C(O).\nMore precisely, the context of an operation is defined blow.\nDefinition 4. The context of an operation\n1. For an original normal operation O, C(O) = DS,\nwhere DS is the representation of the document state\nfrom which O was generated.\n2. For an original inverse operation O, C(O) = C(O) \u00e2\u02c6\u00aa\n{O}, where O is the operation to be undone.\n3. For a transformed operation O , C(O ) = C(O) \u00e2\u02c6\u00aa\n{org(Ox)}, where O = IT(O, Ox). 2\nAccording to the above definition, the context of any type of\noperation can be represented as a set of original operations.\nFor the scenario in Figure 1, we have C(O1) = {}, C(O2) =\n{}, and C(O3) = {O2} according to Definition 4-Item 1.\nAccording to Definition 4-Item 2, we have C(O2) = {O2}.\nFrom O2 = IT(O2, O1), we have C(O2) = {O1} according\nto Definition 4-Item 3.\n3.3 Context-dependency/-independency\nWe define the context-dependency/-independency relation\namong operations in terms of whether an original operation\nis included in the context of another operation of any type.\nDefinition 5. Context-dependency relation \nc\n\u00e2\u2020\u2019\nGiven an original operation Oa and an operation Ob of any\ntype, Ob is context-dependent on Oa, denoted by Oa\nc\n\u00e2\u2020\u2019 Ob,\niff: (1) Oa \u00e2\u02c6\u02c6 C(Ob); or (2) there exists an original operation\nOx, such that Oa \u00e2\u02c6\u02c6 C(Ox) and Ox \u00e2\u02c6\u02c6 C(Ob). 2\nIt should be noted that the context-dependency relation is\ndefined only between an original (either normal or inverse)\noperation and another operation of any type (original or\ntransformed). This is because any operation has a context,\nbut only original operations can be included in a context.\nDefinition 6. Context-independency relation \nc\n\nGiven two original operations Oa and Ob, Oa and Ob are\ncontext-independent, denoted by Oa\nc\nOb, iff neither Oa\nc\n\u00e2\u2020\u2019\nOb, nor Ob\nc\n\u00e2\u2020\u2019 Oa. 2\nIt can be shown that if both Oa and Ob are original normal\noperations, then Oa\nc\n\u00e2\u2020\u2019 Ob is equivalent to Oa \u00e2\u2020\u2019 Ob; and\nOa\nc\nOb is equivalent to Oa Ob. In other words, the\ncausal-dependency/-independency relation is a special case\nof the context-dependency/-independency relation.\n3.4 Context-based conditions\nThe following Context-based Conditions (CC) capture \nessential requirements for operation execution and \ntransformation in OT systems:\n281\nCC1: C(O) \u00e2\u0160\u2020 DS is a necessary condition for an original\noperation O to be transformed to the document state\nDS for execution.\nCC1 ensures that O is always executed after the \ncontextdependent operations included in C(O). In other words,\nfor any original operation Ox, if Ox\nc\n\u00e2\u2020\u2019 O, then Ox\nmust be executed before O. When O is an original \nnormal operation, all operations which are causally before\nO must be included in C(O) (according to Definition 1\nand Definition 5), so CC1 preserves the causal \nordering among original normal operations [4, 22]. When O\nis an original inverse operation, C(O) must include the\noperation to be undone by O (see Definition 4-Item 2),\nso CC1 preserves the do-undo ordering among normal\nand inverse operations [21].\nCC2: DS \u00e2\u02c6\u2019 C(O)1\nis the set of operations that O must be\ntransformed against before O is executed on the \ndocument state DS.\nCC2 ensures that O is transformed against all \ncontextindependent operations in DS before its execution. It\ncan be shown that, for any Ox in DS \u00e2\u02c6\u2019 C(O), it must\nbe that Ox\nc\nO. When O is an original normal \noperation, DS \u00e2\u02c6\u2019 C(O) must include all executed \noperations which are concurrent with O, so CC2 covers\nthe condition that O should be transformed against\nconcurrent operations [4, 22]. When O is an inverse\noperation, CC2 covers the condition that O should be\ntransformed against all operations which are executed\nafter the operation to be undone by O [21].\nCC3: C(O) = DS is a necessary condition for O to be \nexecuted on the document state DS.\nCC3 is required for correctly executing operations.\nCC4: C(Oa) \u00e2\u0160\u2020 C(Ob) is a necessary condition for Oa to be\nIT-transformable to the new context given by C(Ob).\nCC4 is required because if C(Oa) \u00e2\u0160\u2020 C(Ob), then there\nmust be an operation Ox \u00e2\u02c6\u02c6 C(Oa) but Ox \u00e2\u02c6\u02c6 C(Ob),\nwhich means Oa cannot be IT-transformed to the new\ncontext C(Ob) since IT-transformation cannot remove\nthis Ox from C(Oa) (see Definition 4-item3).\nCC5: C(Ob) \u00e2\u02c6\u2019 C(Oa) is the set of operations that Oa must\nbe transformed against before IT-transformed against Ob.\nCC5 ensures that Oa is transformed against \ncontextindependent operations in C(Ob) before IT-transformed\nagainst Ob. It can be shown that, for any Ox in\nC(Ob) \u00e2\u02c6\u2019 C(Oa), it must be that Ox\nc\nOa,\nCC6: C(Oa) = C(Ob) is a necessary condition for Oa to be\nIT-transformed against Ob.\nCC6 is required for correctly applying IT functions.\nIn summary, CC1 and CC4 are required for ensuring \ncorrect ordering of operation execution/transformation; CC2\nand CC5 are required for selecting correct transformation\ntarget operations; and CC3 and CC6 are required for \nensuring correct operation execution/transformation. These\ncontext-based conditions form the foundation for the COT\nalgorithm to be presented in Section 4 and Section 6.\n1\nDS \u00e2\u02c6\u2019 C(O) is the set difference between DS and C(O).\n3.5 Context vector\nAn important element of the operation context theory is\nthe context vector, which represents the set of operations of\na context in an efficient way. For notational convenience,\nwe assume that a collaborative editing session consists of N\ncollaborating sites, identified by 0, 1, . . . , N \u00e2\u02c6\u2019 1.\n3.5.1 Representing original normal operations\nOriginal normal operations generated at each site are strictly\nsequential, so each of them can be uniquely identified by a\npair of integers (sid, ns), where sid is the site identifier and\nns is the local sequence number of this operation.\nLet Oij be an original normal operation generated at site\ni with a sequence number j. If Oij is included in a \ncontext C(O), then Oi1, Oi2, . . . , Oij\u00e2\u02c6\u20191 must also be included\nin C(O) according to Definition 3 and Definition 4. \nTherefore, all normal operations generated at the same site can\nbe sufficiently characterized by the largest sequence \nnumber of these operations. All original normal operations in a\ncontext can be partitioned into N groups according to their\ngeneration sites, so N integers are needed for representing\noriginal normal operations in a context.\n3.5.2 Representing original inverse operations\nAn original inverse operation can be generated to undo\nan original normal operation, or to redo an undone \noperation. Each original inverse operation directly or indirectly\ncorresponds to exactly one original normal operation. For\nexample, inverse operation O may be generated to undo O,\nand O may be generated to undo O. Both O and O \ncorrespond to the same normal operation O. Based on this\nobservation, all original inverse operations in an operation\ncontext can be grouped by their corresponding original \nnormal operations: one inverse group for each undone original\nnormal operation.\nInverse operations in the same inverse group can be \nfurther differentiated by a sequence number based on their \nexecution order within this group. For example, O and O are\nin the same inverse group corresponding to O, so O has the\nsequence number 1, and O has the sequence number 2.\nIn general, an inverse can be identified by a triple (sid, ns, is),\nwhere sid and ns are the site identifier and sequence \nnumber of the corresponding normal operation, and is is the\ninverse sequence number within the group. Since inverses\nare sequentially executed, the largest sequence number in\nthe group can be used to represent all inverses in the group.\nInverse groups can be further partitioned into N inverse\nclusters according to the site identifiers of their \ncorresponding normal operations. The inverse cluster at site i - \nicican be expressed as follows:\nici = [(ns0, is0), (ns1, is1), . . . , (nsk\u00e2\u02c6\u20191, isk\u00e2\u02c6\u20191)],\nwhere each pair (nsj, isj), 0 \u00e2\u2030\u00a4 j < k, represents an inverse\ngroup with isj inverse operations corresponding to the \noriginal normal operation with sequence number nsj at site i. If\nno normal operation at site i has been undone, ici is empty.\n3.5.3 Representing normal and inverse operations\nTo represent an operation context with both original \nnormal and inverse operations, an N-dimensional context \nvector is defined below.\n282\nDefinition 7. Context Vector\nGiven an operation O, its context C(O) can be represented\nby the following context vector CV (O):\nCV (O) = [ (ns0, ic0), (ns1, ic1), . . . , (nsN\u00e2\u02c6\u20191, icN\u00e2\u02c6\u20191) ],\nwhere, for 0 \u00e2\u2030\u00a4 i \u00e2\u2030\u00a4 N \u00e2\u02c6\u2019 1,\n1. nsi represents all original normal operations generated\nat site i, and\n2. ici = [(ns0, is0), (ns1, is1), . . . , (nsk\u00e2\u02c6\u20191, isk\u00e2\u02c6\u20191)] \nrepresents all inverse operations for undoing normal \noperations generated at site i, where (nsj, isj), 0 \u00e2\u2030\u00a4 j < k,\nrepresents an inverse group with isj inverses related to\nthe normal operation with sequence number nsj. 2\nIn the absence of inverse operations in the operation \ncontext, all ici, 0 \u00e2\u2030\u00a4 i \u00e2\u2030\u00a4 N \u00e2\u02c6\u2019 1, would be empty and a Context\nVector would be reduced to a State Vector [4].\nThe vector representation of operation context can also be\nused as the vector representation of the document state. As\nan example, consider the document state after interpreting\nthe undo command Undo(O2) in Figure 1. Since Undo(O2)\nis interpreted as an inverse O2 (see Section 4.2), the \ndocument state after executing (the transformed) O2 shall be\nDS = {O1, O2, O3, O2}. This document state cannot be\nrepresented by a state vector but can be represented as a\ncontext vector as follows: CV (DS) = [(1, [ ]), (2, [(1, 1)]].\nBased on Definition 7, it is straightforward to derive the\nscheme for maintaining the vector representation for the\ndocument state after executing each operation (according\nto Definition 3). Moreover, the vector representation of \noperation context can also be used to efficiently detect \ncontextdependency/-independency relations. Due to space \nlimitation, these technical details are omitted in this paper.\n4. THE BASIC COT ALGORITHM\nIn the basic COT algorithm, we assume each site \nmaintains a document state DS, which contains the set of original\noperations executed so-far. This is different from the log or\nthe History Buffer (HB) schemes in prior OT algorithms [4,\n22, 23], which record a list of transformed operations. We\ndeliberately leave the internal data structure of DS \nunspecified to keep the COT algorithm independent of the operation\nbuffering strategy.\nIn algorithm description, we shall use the context set \nrepresentation C(O), rather than the context vector \nrepresentation CV (O). When an operation O is propagated from the\nlocal site to remote sites, however, it is the context vector,\nnot the context set, that is actually piggy-backed on O for\npropagation. The set of operations in C(O) can be easily\ndetermined from DS based on the information in CV (O).\nThe COT algorithm has two parts: the COT-DO part\nfor supporting consistency maintenance (do), and the \nCOTUNDO part for supporting undo. Both parts share the\nsame core context-based transformation procedure. \nOperation context and context-based conditions are central to\nthe whole COT algorithm.\n4.1 COT-DO\nCOT-DO takes two parameters: O - an original operation\nto be executed, and DS - the current document state \nrepresentation. COT-DO is invoked only if C(O) \u00e2\u0160\u2020 DS (CC1),\nwhich ensures that all operations included in the context of\nO have already been executed on DS.\nAlgorithm 1. COT-DO(O, DS)\n1. transform(O, DS \u00e2\u02c6\u2019 C(O));\n2. Execute O; DS := DS \u00e2\u02c6\u00aa {org(O)}.\nProcedure 1. transform(O, CD)\nRepeat until CD = { }:\n1. Remove Ox from CD, where C(Ox) \u00e2\u0160\u2020 C(O);\n2. transform(Ox, C(O) \u00e2\u02c6\u2019 C(Ox));\n3. O := IT(O, Ox); C(O) := C(O) \u00e2\u02c6\u00aa {org(Ox)}.\nCOT-DO first invokes procedure transform() to transform\nO against operations in DS \u00e2\u02c6\u2019 C(O) (CC2). This is to \nupgrade the context of O to DS. In Step 2, it must be that\nC(O) = DS (CC3), so O is executed as-is, and the original\nof O is added to DS (according to Definition 3-Item 2).\nThe heart of COT-DO is transform(O, CD), whose task is\nto transform O against operations in CD, which represents\nthe context difference between C(O) and a new context on\nwhich O is to be defined. This procedure repeats the \nfollowing three steps until CD becomes empty:\n1. Remove an operation Ox from CD, where C(Ox) \u00e2\u0160\u2020\nC(O) (CC4). An operation Ox meeting this condition\ncan be determined if all operations in CD are sorted in\nthe order of their execution and sequentially retrieved.\n2. The procedure transform() is recursively invoked to\ntransform Ox against operations in C(O)\u00e2\u02c6\u2019C(Ox) (CC5).\nThis is to upgrade Ox to the context of O, so that they\ncan be used for IT transformation in the next step.\n3. After the recursive call to transform(), it must be that\nC(O) = C(Ox) (CC6), so O is IT-transformed against\nOx, and the context of O is updated by adding the\noriginal of Ox (according to Definition 4-Item 3).\nTo show how COT-DO works, we examine how it resolves\nthe dOPT-puzzle in Figure 1. Consider the operation \nexecutions at site 0, with the initial document state DS0 = { }.\n1. After the generation of O1, since C(O1) = DS0, O1 is\nexecuted as-is and DS0 is updated to DS1 = {O1}.\n2. When O2 arrives with C(O2) = {}, transform(O2, DS1\u00e2\u02c6\u2019\nC(O2)) is called, where DS1 \u00e2\u02c6\u2019 C(O2) = {O1}.\nInside transform(O2, {O1}), since C(O1) = C(O2), we\nhave O2 := IT(O2, O1), and C(O2) = {O1}.\nReturning from transform(O2, {O1}), we have C(O2) =\nDS1, so O2 is executed, and DS1 is updated to DS2 =\n{O1, O2}, where O2 = org(O2).\n3. When O3 arrives with C(O3) = {O2}, transform(O3, DS2\u00e2\u02c6\u2019\nC(O3)) is called, where DS2 \u00e2\u02c6\u2019 C(O3) = {O1}.\nInside transform(O3, {O1}), transform(O1, C(O3)\u00e2\u02c6\u2019C(O1))\nis recursively called, with C(O3) \u00e2\u02c6\u2019 C(O1) = {O2},\nwhich is the key step in detecting the dOPT-puzzle.\nIn the recursive transform(O1, {O2}), since C(O2) =\nC(O1), we have O1 := IT(O1, O2), and C(O1) = {O2}.\nReturning from the recursion, we have C(O1) = C(O3),\nso C(O3) := IT(O3, O1) (the dOPT-puzzle resolved\nhere), and C(O3) = {O1, O2}, where O1 = org(O1).\nAfter returning from transform(O3, {O1}), C(O3) =\nDS2; so O3 is executed, and DS2 is updated to DS3 =\n{O1, O2, O3}, where O3 = org(O3).\n283\n4.2 COT-UNDO\nTo undo an operation O, a meta-level undo command\nUndo(O) must be issued by a user. How to generate the\nundo command for selecting any operation to undo is part\nof the undo policy [21]. This paper is confined to the \ndiscussion of the undo mechanism, which determines how to undo\nthe selected operation in a given context.\nIn COT-UNDO, Undo(O) is interpreted as an inverse O,\nthat is context-dependent on operations in C(O) and O itself.\nCOT-UNDO takes two input parameters: O is the operation\nselected to be undone, which can be any operation done \nsofar, and DS is the current document state representation.\nAlgorithm 2. COT-UNDO(O, DS)\n1. O := makeInverse(O); C(O) := C(O) \u00e2\u02c6\u00aa {O};\n2. COT-DO(O, DS).\nCOT-UNDO works by first creating an inverse O by \ninvoking makeInverse(O)2\n, with its context C(O) := C(O) \u00e2\u02c6\u00aa {O}\n(according to Definition 4-Item 2), and then invoking \nCOTDO to handle O.\nFor example, to interpret Undo(O2) in Figure 1, \nCOTUNDO is invoked with parameters O2 and DS = {O1, O2, O3}.\nFirst, O2 and C(O2) = {O2} are created. Then, COT-DO\nis invoked with parameters O2 and DS. Inside COT-DO,\ntransform(O2, DS \u00e2\u02c6\u2019 C(O2)) shall be invoked, and O2 shall\nbe correctly transformed against O1 and O3 since CD =\nDS \u00e2\u02c6\u2019 C(O2) = {O1, O3}. This example shows that an \ninverse operation can be handled by COT-DO in the same way\nas other normal operations. This is because context-based\nconditions CC1 - CC6 are uniformly applicable to both \nnormal and inverse operations.\nThe basic COT algorithm is simple yet powerful - \ncapable of doing and undoing any operations at anytime. Among\nall prior OT systems, only the combination of GOTO and\nANYUNDO (referred as GOTO-ANYUNDO) has similar\ncapabilities [22, 21].\n5. TRANSFORMATION PROPERTIES\nCOT is a high-level control algorithm responsible for \ndetermining which operation should be transformed against\nother operations and in which order according to \ncontextbased conditions. Another important component of an OT\nsystem is the low-level transformation functions \nresponsible for transforming operations according to their types and\nparameters. Past research has identified a range of \ntransformation properties/conditions that must be maintained for\nensuring the correctness of an OT system. Different OT \nsystems may have different control algorithms, different \ntransformation functions, and different divisions of \nresponsibilities among these components.\nUnlike GOTO-ANYUNDO, the basic COT algorithm does\nnot use ET (Exclusion Transformation) functions [21], thus\navoiding the requirement of the Reversibility Property (RP)\nbetween IT and ET functions [21].\nSimilar to GOTO-ANYUNDO, the basic COT algorithm\nassumes that underlying transformation functions are \ncapable of preserving the following properties [4, 15, 19, 23, 21]:\n2\nThe reader is referred to [25] for precise definitions of three\nprimitive operations Insert, Delete and Update and their \ncorresponding inverses. The makeInverse(O) procedure directly \nfollows these definitions.\n1. Convergence Property 1 (CP1)3\n. Given a \ndocument state DS, and operations Oa, Ob, if Oa =\nIT(Oa, Ob), and Ob = IT(Ob, Oa), then it must be:\nDS \u00e2\u2014\u00a6 [Oa, Ob] = DS \u00e2\u2014\u00a6 [Ob, Oa],\nwhich means that [Oa, Ob] and [Ob, Oa] are equivalent\nwith respect to the effect on the document state DS.\n2. Convergence Property 2 (CP2). Given three \noperations O, Oa and Ob, if Oa = IT(Oa, Ob) and Ob =\nIT(Ob, Oa), then it must be:\nIT(IT(O, Oa), Ob) = IT(IT(O, Ob), Oa),\nwhich means that [Oa, Ob] and [Ob, Oa] are equivalent\nwith respect to the effect in transformation.\n3. Inverse Property 2 (IP2)4\n. Given any operation Ox\nand a pair of operations [O, O], it must be:\nIT(IT(Ox, O), O) = IT(Ox, I) = Ox,\nwhich means that [O, O] and I are equivalent with \nrespect to the effect in transformation.\n4. Inverse Property 3 (IP3). Given two operations Oa\nand Ob, if Oa := IT(Oa, Ob), Ob := IT(Ob, Oa), and\nOa := IT(Oa, Ob), then it must be:\nOa = Oa,\nwhich means the transformed inverse operation Oa is\nequal to the inverse of the transformed operation Oa.\nThe above transformation properties are important \ndiscoveries of past research, but they are not unconditionally\nrequired. The pre-conditions for requiring them, however,\nwere never explicitly stated in their specifications, which has\nunfortunately caused quite some misconceptions in OT \nliterature. To explore alternative solutions to these properties,\nwe explicitly state the Pre-Conditions (PC) for CP1, CP2,\nIP2, and IP3 as follows:\n1. PC-CP1: CP1 is required only if the OT system \nallows the same group of context-independent operations\nto be executed in different orders.\n2. PC-CP2: CP2 is required only if the OT system \nallows an operation to be transformed against the same\ngroup of context-independent operations in different\norders.\n3. PC-IP2: IP2 is required only if the OT system allows\nan operation Ox to be transformed against a pair of\ndo and undo operations (O and O) one-by-one.\n4. PC-IP3: IP3 is required only if the OT system allows\nan inverse operation Oa to be transformed against \nanother operation Ob that is context-independent of Oa.\n3\nConvergence Property 1 & 2 in this paper (and in [21]) are\nthe same as Transformation Property 1 & 2 in [19].\n4\nThere is another Inverse Property 1 (IP1) that is required in\nan OT system for achieving the correct undo effect [21], but IP1\nis not related to IT functions.\n284\nThere are generally two ways to achieve OT correctness\nwith respect to these transformation properties: one is to\ndesign transformation functions capable of preserving these\nproperties; the other is to design control algorithms capable\nof breaking the pre-conditions for requiring these properties.\nPast research has shown that it is relatively easy to \ndesign transformation functions capable of preserving CP1,\nbut non-trivial to design and formally prove transformation\nfunctions capable of preserving CP2, IP2 and IP3. \nCounterexamples illustrating the violation of these properties in\nsome early published transformation functions can be found\nin [23, 21, 8, 11]. IT functions capable of preserving IP2\nand IP3 had been devised in the context of ANYUNDO [21],\nbut our experience in implementing these functions revealed\nthat those solutions are quick intricate and inefficient (more\nanalysis can be found in Section 7).\nClearly, solving CP2, IP2 and IP3 at the control algorithm\nlevel has the benefit of simplifying the design of \ntransformation functions and the OT system as a whole. In the \nfollowing section, we extend the basic COT algorithm to provide\nsimple and efficient solutions to CP2, IP2 and IP3 at the\ncontrol algorithm level.\n6. COT SOLUTIONS TO CP2, IP2, AND IP3\nA distinctive feature of COT is that in every \ntransformation process (i.e. an invocation of transform(O, CD)),\nthe whole set of transformation target operations are \ndetermined in advance, and available in the context-difference \nparameter CD (calculated by using context-based conditions\nCC2 and CC5). With the knowledge of all operations \ninvolved in the transformation process, we are able to \nproperly arrange these operations to break the pre-conditions for\nCP2, IP2, and IP3.\n6.1 Extended transform() procedure\nWe extend the core procedure transform(O, CD) to take\nadvantage of the global knowledge of operations in the \ncontextdifference parameter CD for breaking PC-CP2, PC-IP2 and\nPC-IP3. The extended transform(), as shown in \nProcedure 2, retains the structure and main elements of \nProcedure 1, but adds solutions to CP2, IP2, and IP3 in Step 1\n(ensure TPsafety()) and in Step 2-(c) (the if-then part).\nProcedure 2. transform(O, CD)\n1. If CD = { }, ensure TPsafety(O, CD);\n2. Repeat until CD = { }:\n(a) Remove the first operation Ox from CD;\n(b) transform(Ox, C(O) \u00e2\u02c6\u2019 C(Ox));\n(c) If Ox is a do-undo-pair,\nthen C(O) := C(O) \u00e2\u02c6\u00aa {org(Ox), org(Ox)};\nelse O := IT(O, Ox); C(O) := C(O) \u00e2\u02c6\u00aa {org(Ox)}.\nProcedure 3. ensure TPsafety(O, CD)\n1. Ensure CP2-safety: sort operations in CD in a total\norder that respects their context-dependency order.\n2. Ensure IP2-safety: for any Ox \u00e2\u02c6\u02c6 CD, if Ox \u00e2\u02c6\u02c6 CD,\nthen mark Ox as a do-undo-pair, remove Ox from CD.\n3. Ensure IP3-safety: if O is inverse, the invoke\nmake IP3safe Inverse(O, CD).\nProcedure 4. make IP3safe Inverse(O, CD)\n1. O := makeInverse(O); C(O) := C(O) \u00e2\u02c6\u2019 {O};\n2. NCD := {Ox | Ox \u00e2\u02c6\u02c6 CD and Ox\nc\nO};\n3. transform(O, NCD);\n4. O := makeInverse(O); C(O) := C(O) \u00e2\u02c6\u00aa {O};\n5. CD := CD \u00e2\u02c6\u2019 NCD.\n6.2 Breaking the pre-condition for CP2\nThe COT solution to CP2 is to sort all operations in CD\nin a total order which respects their context-dependency \norder (in Step 1 of ensure TPsafety()). If an operation O is\ntransformed against the same group of context-independent\noperations in multiple invocations to transform(O, CD), this\ngroup of operations must be included in CD and sorted in\nthe same total order. Therefore, O can never be transformed\nagainst the same group of operations in different orders, thus\nbreaking PC-CP2.\nIt should be noted that CD becomes an ordered set after\nthe sorting. The first Ox in CD must meet the condition\nC(Ox) \u00e2\u0160\u2020 C(O) in Step 2(a) of transform(O, CD) \n(Procedure 1), so this condition is no longer explicitly specified\nin Procedure 2. A correct total order for breaking \nPCCP2 can be conveniently determined by using the \ncontextdependency relations among all operations plus the site \nidentifiers of context-independent operations.\nThere have been several prior OT systems capable of \nbreaking PC-CP2, including the GOT system (by an undo/redo\nscheme based on total ordering) [23], the SOCT4 system\n(by a control strategy based on global sequencing) [26], the\nNICE system (by a central transformation-based notifier) [20],\nand the TIBOT system (by a distributed synchronization\nprotocol based on time-internal) [12]. The COT solution to\nCP2 is unique and avoids the use of any undo/redo or global\nsequencing/synchronization.\n6.3 Breaking the pre-condition for IP2\nThe basic idea of the COT solution to IP2 is to make\nsure that an operation is never transformed against a pair\nof do and undo operations one by one, thus breaking \nPCIP2. This solution consists of two parts: (1) Step 2 of\nensure TPsafety(CD) couples operations with their \ncorresponding inverses if they are all included in the context \ndifference CD, and remove these inverses from CD; (2) In Step\n2-(c) of transform(), if Ox is found to be a do-undo-pair, the\nIT-transformation of O against Ox is skipped (effectively\ntreating this pair as an identity operation) and the context of\nO is updated by adding two operations: {org(Ox), org(Ox)}.\n6.4 Breaking the pre-condition for IP3\nThe COT solution to IP3 is encapsulated in the procedure\nmake IP3safe Inverse(O, CD), which makes O an IP3-safe\ninverse with respect to the context difference CD. An \ninverse O is IP3-safe with respect to CD if it is made from a\ntransformed version of O, which has included all operations\nin CD that are context-independent of O. Under the control\nof COT, the IP3-safe inverse O shall never be transformed\nagainst operations that are context-independent of O, thus\nbreaking PC-IP3.\nThe make IP3safe Inverse procedure works as follows: (1)\ncreate operation O (the inverse of O) and C(O) = C(O) \u00e2\u02c6\u2019\n285\n{O}; (2) select all operations from CD which are \ncontextindependent of O and create a new context difference NCD;\n(3) transform O against operations in NCD (by recursively\ninvoking transform()); (4) create a new inverse from the\ntransformed O; and (5) create a new CD by subtracting\nNCD from the old CD (the new CD must maintain the \ntotal order as required for solving CP2). This new inverse\nO must be IP3-safe because it is created from a \ntransformed operation whose context has included all operations\nin NCD. The IP3-safe inverse O shall never be transformed\nagainst the operations in NCD since these operations have\nbeen removed from the new CD in Step (5).\n7. DISCUSSIONS\n7.1 The theory of operation context\nThe notion of operation context was first proposed in the\nGOT algorithm [23] and used in conjunction with the \ntheory of causality in follow-up GOTO and ANYUNDO \nalgorithms [22, 21]. In prior work, the context of an operation O\nwas defined as a sequence of transformed operations which\ncan be executed to bring the document from its initial state\nto the state on which O is defined. This definition is directly\ncoupled to the sequential history buffering strategy, which\nsaves executed operations in their execution forms and \norders. There was no explicit representation of an operation\ncontext. Context relationships among operations are \nderived from the causality relationships plus the history buffer\nposition relationships among operations [23, 21].\nIn this paper, the concept of operation context is defined\nas a set of original operations corresponding to the \ndocument state on which this operation is defined. This new\nconcept of operation context is independent of the \nunderlying operation buffering strategy and is explicitly represented\nas an operation set. Based on the set representation of \noperation context, essential OT conditions (CC1 - CC6) have\nbeen precisely and concisely captured. Moreover, the \ncontext vector has been devised to efficiently represent both\nnormal and inverse operations in a context. The context\nvector is more general than the state vector and potentially\napplicable to other distributed computing systems as well.\nBased on the theory of causality, prior OT algorithms\nhave used state vectors to capture causal-dependency \nrelationships among original normal operations and to \nrepresent document states in terms of original normal \noperations. However, causal-dependency relationships are not\ndefined for inverse or transformed operations, and state \nvectors cannot represent document states with original inverse\noperations. The theory of causality is unable to capture \nessential OT conditions (CC1 - CC6) for all types of operation\n- original and transformed, normal and inverse operations.\n7.2 COT versus GOTO-ANYUNDO\nBoth COT and GOTO-ANYUNDO are capable of doing\nand undoing any operations at anytime. The main \ndifference is that COT achieves this capability without using ET\nfunctions (thus eliminating the RP requirement for IT \nfunctions), and without requiring IT functions to preserve CP2,\nIP2 and IP3. The avoidance of RP, CP2, IP2, and IP3 has\nsignificantly simplified the design of transformation \nfunctions and the OT system as a whole.\nCOT is simpler than GOTO-ANYUNDO (and prior OT\nalgorithms based on the causality theory) because of the use\nof a single theory of operation context for capturing all \nOTrelated conditions (CC1-CC6), the uniformity of \ncontextbased conditions for treating all types of operation, and the\nconciseness of these context-based conditions.\nThe COT-based system is more efficient than the \nGOTOANYUNDO-based system in solving IP2 and IP3. In \nGOTOANYUNDO, the do-part (a normal operation) and the \nundopart (an inverse operation) need to be coupled for the \npurpose of preserving IP2 [21]. An eager coupling strategy\nwas adopted: an inverse operation is coupled with its \ncorresponding normal operation immediately after its execution.\nUnder this scheme, inverse operations are not explicitly \nrepresented in the history buffer. When a normal operation\nis to be executed, however, it may need to be transformed\nagainst only the undo-part of a do-undo-pair. To cope with\nthis problem, an extra DeCouple-GOTO-ReCouple scheme\nhas to be used to decouple a do-undo-pair before \ninvoking GOTO and then recouple them afterwards [21]. \nHowever, the implementation of this decouple-recouple scheme\nrevealed it was rather intricate and causing many repeated\ntransformations.\nIn the COT algorithm, COT-DO and COT-UNDO are\nseamlessly integrated. Inverse operations are explicitly \nrepresented in the operation context, and a lazy coupling \nstrategy is adopted: the coupling of a do-undo-pair occurs not \nimmediately after executing each inverse, but only when both\nthe do-part and the undo-part appear in the same \ntransformation process at some late stage. These strategies help to\navoid overhead transformations caused by the eager coupling\nscheme and the decouple-recouple scheme.\nIn the GOTO-ANYUNDO-based system, the solution to\nIP3 is encapsulated in an IP3-preserving IT function, called\nIP3P-IT [21]. Inside this function, an extended ET function\nhas to be used, which may invoke the expensive GOTO \nalgorithm to ensure RP with the corresponding IT function.\nIn contrast, the COT solution to IP3 is encapsulated in the\nhigh-level procedure make IP3safe Inverse(O, CD), which is\nmore efficient since (1) it avoids converting O to O back and\nforth multiple times for each Ox \u00e2\u02c6\u02c6 NCD (if IP3P-IT(O, Ox)\nwere used instead); and (2) the transform() procedure is\nmuch cheaper than GOTO.\n7.3 OT buffering strategies\nAnother distinctive feature of the COT algorithm is the\nseparation of the algorithm from the underlying operation\nbuffering strategy. This has not only resulted in a cleaner\nand simpler logical structure to the algorithm itself, but also\nallowed a range of performance optimizations at the \noperation buffering level.\nWe have devised and implemented a buffering structure in\nwhich not only original operations but also transformed \nversions can be saved; and all transformed operations from the\nsame original operation are organized in the same version\ngroup. When an original operation is required at the COT\nalgorithm level, the corresponding version group is searched\nfor a version that matches the context requirement. If such\na version already exists, it is used to represent the \noriginal operation in the transformation process, thus saving the\noverhead to transform the original operation into this \nversion. Under this buffering structure, various heuristics can\nbe used to selectively save transformed versions to maximize\ntheir reuse and minimize their space usage. By \nexperimentation, we have identified some useful heuristics that are\n286\neffective in saving transformations for a number of common\npatterns of operation sequence.\nCOT is not the first OT algorithm that buffers and uses\noriginal operations for transformation. Several prior OT\nalgorithms, including CCU [2], adOPTed [19], and \nGOTOANYUNDO [21], have also buffered original operations. COT\nis unique in its way of buffering and using original, as well\nas transformed, operations.\n7.4 OT correctness\nOT correctness is a central topic of discussion in OT \nresearch. In this section, we provide our observations and\nopinions on some important OT correctness issues.\nOT is a complex system with multiple interrelated \ncomponents. A system-oriented approach is needed for addressing\nOT issues. An experimental method, called \npuzzle-detectionresolution, has commonly been used in exploring and \nrefining OT solutions. Puzzles are subtle but representative\nscenarios in which certain OT properties/conditions may be\nviolated and the system may produce incorrect results. The\nability to solve all known puzzles is a necessary condition\nand an important indicator of the soundness of an OT \nsystem. In research literature, simple puzzle scenarios are \noften used to illustrate the key reasons why an OT system\nworks or fails. In real OT system design, however, a real\nimplementation and comprehensive testing cases based on\ncomplex puzzle scenarios are crucial in validating a design.\nTheoretical methods have also been used to formally \nverify OT correctness with respect to some identified \ntransformation properties/conditions. Formal verification can be\neffective if the correctness issues have been well-understood\nand the verification criteria and boundary conditions have\nbeen well-defined. In this regard, experimental methods\nlike puzzle-detection-resolution can play an important role\nin gaining the necessary insights into the real correctness\nissues, and establishing suitable criteria and conditions for\nformal verification.\nA systematic approach is needed in conducting both \nexperimental and theoretic OT research. Many OT \ncomponents and issues are intimately related, and a solution to\none issue, if examined in isolation, is unlikely to be \ncorrect or complete. For example, a solution that works well\nfor consistency maintenance (do), may fail when both do\nand undo problems are considered; and an undo solution\n(e.g. preserving IP2) may violate the solution to \nconsistency maintenance [21]. A complete OT solution to both do\nand undo problems is significantly more difficult to design\nthan a partial solution to only one of them.\nOn the other hand, a difficult issue in one OT component\nmay be resolved easily, or avoided altogether, if this issue\nis addressed from a different OT component. For example,\nit is known that devising and proving transformation \nfunctions capable of preserving properties CP2, IP2, and IP3\nare difficult. However, these difficulties can be avoided by\ndevising control algorithms (like COT) capable of breaking\nthe pre-conditions for requiring these properties; it is also\neasier to prove a control algorithm is capable of breaking\nthe pre-conditions for these properties, than to prove \ntransformation functions are capable of preserving them.\nDifferent OT systems may have different divisions of \nresponsibility among their components and hence different\ncorrectness requirements for these components. Caution\nmust be taken in interpreting correctness results. For \nexample, CP1 and CP2 were proven to be necessary and \nsufficient for adOPTed-based systems to converge [19, 13], but\nthis result cannot be generalized to all OT systems. In fact,\nCP1 and CP2 are neither sufficient nor necessary for many\nOT systems. They are insufficient because an OT system\nmay need to preserve additional properties/conditions, such\nas IP2, IP3, and those summarized in [21]. They are \nunnecessary if the pre-conditions for requiring them have been\nbroken. For example, neither CP1 nor CP2 is required in the\nREDUCE system based on the GOT algorithm for ensuring\nconvergence [23]. CP2 is also not required by OT systems\nbased on COT or some prior OT algorithms [26, 20, 12].\nOne OT correctness issue, which is often discussed in \nrelation to the CP2-violation problem, is the false-tie problem:\nwhen two (or more) insert operations with the same position\nare IT-transformed with each other, the position tie may be\nfalse if it was not original but caused by previous \ntransformations. An OT system may fail to produce correct results\nif the normal tie-breaking rule (e.g. based on site \nidentifiers) is used to break false-ties. This problem was long\ndiscovered in early OT work and a concrete scenario related\nto this problem was illustrated in Fig. 6 of [23]. It is beyond\nthe scope of this paper to discuss solutions to this problem,\nbut it is worth pointing out that the false-tie problem is\ndifferent from the CP2-violation problem: a false-tie may\noccur without violating CP2. In our view, the false-tie\nproblem is an issue at the transformation function level and\nits solution could and should be localized at this level as\nwell. For alternative views and approaches to this problem,\nthe reader is referred to [8, 11, 5].\nThe COT algorithm has been implemented and validated\nby a comprehensive testing suite covering all known OT\npuzzle scenarios. In this paper, informal analysis and \nsimple puzzle scenarios have been used to show the \ncorrectness of COT with respect to various transformation \nproperties/conditions. Formal verification of COT correctness\nwith respect to these properties/conditions, and \nquantitative analysis of the time and space complexity of COT, shall\nbe reported in a journal version of this paper.\n8. CONCLUSIONS\nWe have contributed the theory of operation context and\nthe COT (Context-based OT) algorithm. The theory of \noperation context is capable of capturing essential relationships\nand conditions for all types of operation in an OT system;\nit provides a new foundation for better understanding and\nresolving OT problems. The COT algorithm provides \nuniformed solutions to both consistency maintenance and undo\nproblems; it is simpler and more efficient than prior OT \ncontrol algorithms with similar capabilities; and it significantly\nsimplifies the design of transformation functions. The COT\nalgorithm has been implemented in a generic collaboration\nengine and used for supporting a range of novel collaborative\napplications [24].\nReal-world applications provide exciting opportunities and\nchallenges to future OT research. The theory of operation\ncontext and the COT algorithm shall serve as new \nfoundations for addressing the technical challenges in existing and\nemerging OT applications.\nAcknowledgments\nThe authors are grateful to Bo Begole and anonymous \nreviewers for their valuable comments and suggestions which\nhave helped improve the presentation of the paper.\n287\n9. REFERENCES\n[1] J. Begole, M. Rosson, and C. Shaffer. Flexible\ncollaboration transparency: supporting worker\nindependence in replicated application-sharing\nsystems. ACM Trans. on Computer-Human\nInteraction, 6(2):95-132, 1999.\n[2] G. Cormack. A calculus for concurrent update. In\nResearch Report CS-95-06, Dept. of Computer\nScience, University of Waterloo, Canada, 1995.\n[3] A. Davis, C. Sun, and J. Lu. Generalizing operational\ntransformation to the standard general markup\nlanguage. In Proc. of the ACM Conf. on\nComputer-Supported Cooperative Work, pages 58 - 67,\nNov. 2002.\n[4] C. A. Ellis and S. J. Gibbs. Concurrency control in\ngroupware systems. In Proc. of the ACM Conf. on\nManagement of Data, pages 399-407, May 1989.\n[5] N. Gu, J. Yang, and Q.Zhang. Consistency\nmaintenance based on the mark & retrace technique\nin groupware systems. In Proc. of ACM Conf. on\nSupporting Group Work, pages 264-273, Nov. 2005.\n[6] R. Guerraoui and Corine Hari. On the consistency\nproblem in mobile distributed computing. In\nProceedings of the Second ACM International\nWorkshop on Principles of Mobile Computing, pages\n51-57, New York, Octo 2002. ACM.\n[7] C. Ignat and M.C. Norrie. Customizable collaborative\neditor relying on treeOPT algorithm. In Proc. of the\nEuropean Conf. of Computer-supported Cooperative\nWork, pages 315-324, Sept. 2003.\n[8] A. Imine, P. Molli, G. Oster, and M. Rusinowitch.\nProving correctness of transformation functions in\nreal-time groupware. In Proc. of the European Conf.\non Computer-Supported Cooperative Work, Sept. 2003.\n[9] L. Lamport. Time, clocks, and the ordering of events\nin a distributed system. Communication of ACM,\n21(7):558-565, 1978.\n[10] D. Li and R. Li. Transparent sharing and\ninteroperation of heterogeneous single-user\napplications. In Proc. of the ACM Conf. on\nComputer-Supported Cooperative Work, pages\n246-255, Nov. 2002.\n[11] D. Li and R. Li. Preserving operation effects relation\nin group editors. In Proc. of the ACM Conf. on\nComputer-Supported Cooperative Work, pages\n457-466, Nov. 2004.\n[12] R. Li, D. Li, and C. Sun. A time interval based\nconsistency control algorithm for interactive\ngroupware applications. In Proc. of International\nConference on Parallel and Distributed Systems, pages\n429-436, July. 2004.\n[13] B. Lushman and G. Cormack. Proof of correctness of\nRessels adOPTed algorithm. Information Processing\nLetters, (86):303-310, 2003.\n[14] C. Palmer and G. Cormack. Operation transforms for\na distributed shared spreadsheet. In Proc. of the ACM\nConf. on Computer-Supported Cooperative Work,\npages 69-78, Nov. 1998.\n[15] A. Prakash and M. Knister. A framework for undoing\nactions in collaborative systems. ACM Trans. on\nComputer-Human Interaction, 4(1):295-330, Dec.\n1994.\n[16] N. Preguica, M. Shapiro, and J. Legatheaux Martins.\nAutomating semantics-based reconciliation for mobile\ndatabases. In Proceedings of the 3th Conference\nFrancaise sur les Systems d\"Exploitation, Octo 2003.\n[17] M. Raynal and M. Singhal. Logical time: capturing\ncausality in distributed systems. IEEE Computer\nMagazine, 29(2):49-56, Feb. 1996.\n[18] M. Ressel and R. Gunzenh\u00c2\u00a8auser. Reducing the\nproblems of group undo. In Proc. of the ACM Conf.\non Supporting Group Work, pages 131-139, Nov. 1999.\n[19] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh\u00c2\u00a8auser.\nAn integrating, transformation-oriented approach to\nconcurrency control and undo in group editors. In\nProc. of the ACM Conf. on Computer-Supported\nCooperative Work, pages 288-297, Nov. 1996.\n[20] H.F. Shen and C. Sun. A flexible notification\nframework for collaborative systems. In Proc. of the\nACM Conf. on Computer-Supported Cooperative\nWork, pages 77-86, Nov. 2002.\n[21] C. Sun. Undo as concurrent inverse in group editors.\nACM Trans. on Computer-Human Interaction,\n9(4):309-361, December 2002.\n[22] C. Sun and C. A. Ellis. Operational transformation in\nreal-time group editors: issues, algorithms, and\nachievements. In Proc. of the ACM Conf. on\nComputer-Supported Cooperative Work, pages 59-68,\nNov. 1998.\n[23] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.\nAchieving convergence, causality-preservation, and\nintention-preservation in real-time cooperative editing\nsystems. ACM Trans. on Computer-Human\nInteraction, 5(1):63-108, March 1998.\n[24] C. Sun, Q. Xia, D. Sun, D. Chen, H.F. Shen, and\nW. Cai. Transparent adaptation of single-user\napplications for multi-user real-time collaboration.\nACM Trans. on Computer-Human Interaction, 2006.\n[25] D. Sun, S. Xia, C. Sun, and D. Chen. Operational\ntransformation for collaborative word processing. In\nProc. of the ACM Conf. on Computer-Supported\nCooperative Work, pages 437-446, Nov. 2004.\n[26] N. Vidot, M. Cart, J. Ferri\u00c2\u00b4e, and M. Suleiman. Copies\nconvergence in a distributed real-time collaborative\nenvironment. In Proc. of the ACM Conf. on\nComputer-Supported Cooperative Work, pages\n171-180, Dec. 2000.\n[27] S. Xia, D. Sun, C. Sun, and D. Chen. A collaborative\ntable editing technique based on transparent\nadaptation. In Proc. of the International Conf. on\nCooperative Information Systems, LNCS Vol. 3760,\nSpringer Verlag, pages 576-592, Nov. 2005.\n[28] S. Xia, D. Sun, C. Sun, and D. Chen.\nObject-associated telepointer for real-time\ncollaborative document editing systems. In Proc. of\nthe IEEE Conf. on Collaborative Computing:\nNetworking, Applications and Worksharing, Dec. 2005.\n[29] S. Xia, D. Sun, C. Sun, D. Chen, and H.F. Shen.\nLeveraging single-user applications for multi-user\ncollaboration: the CoWord approach. In Proc. of the\nACM Conf. on Computer-Supported Cooperative\nWork, pages 162-171, Nov. 2004.\n288\n": ["operational transformation", "cot", "context-based ot", "causal-dependency", "concurrency condition", "concurrency relation", "inverse operation", "document state", "original operation", "transformed operation", "inverse cluster", "vector representation of operation context", "operation context vector representation", "history buffer", "exclusion transformation", "operation context", "ot", "context-base ot", "consistency maintenance", "undo", "group editor", "distribute application", ""]}