{"Encryption-Enforced Access Control in Dynamic\nMulti-Domain Publish/Subscribe Networks\nLauri I.W. Pesonen\nUniversity of Cambridge,\nComputer Laboratory\nJJ Thomson Avenue,\nCambridge, CB3 0FD, UK\n{first.last}@cl.cam.ac.uk\nDavid M. Eyers\nUniversity of Cambridge,\nComputer Laboratory\nJJ Thomson Avenue,\nCambridge, CB3 0FD, UK\n{first.last}@cl.cam.ac.uk\nJean Bacon\nUniversity of Cambridge,\nComputer Laboratory\nJJ Thomson Avenue,\nCambridge, CB3 0FD, UK\n{first.last}@cl.cam.ac.uk\nABSTRACT\nPublish/subscribe systems provide an efficient, event-based,\nwide-area distributed communications infrastructure. Large\nscale publish/subscribe systems are likely to employ \ncomponents of the event transport network owned by cooperating,\nbut independent organisations. As the number of \nparticipants in the network increases, security becomes an \nincreasing concern. This paper extends previous work to present\nand evaluate a secure multi-domain publish/subscribe \ninfrastructure that supports and enforces fine-grained access\ncontrol over the individual attributes of event types. Key\nrefresh allows us to ensure forward and backward security\nwhen event brokers join and leave the network. We \ndemonstrate that the time and space overheads can be minimised\nby careful consideration of encryption techniques, and by\nthe use of caching to decrease unnecessary decryptions. We\nshow that our approach has a smaller overall \ncommunication overhead than existing approaches for achieving the\nsame degree of control over security in publish/subscribe\nnetworks.\nCategories and Subject Descriptors\nC.2.4 [Computer-Communication Networks]: \nDistributed Systems-Distributed applications\nGeneral Terms\nSecurity, Performance\n1. INTRODUCTION\nPublish/subscribe is well suited as a communication \nmechanism for building Internet-scale distributed event-driven \napplications. Much of its capacity for scale in the number\nof participants comes from its decoupling of publishers and\nsubscribers by placing an asynchronous event delivery \nservice between them. In truly Internet-scale publish/subscribe\nsystems, the event delivery service will include a large set\nof interconnected broker nodes spanning a wide geographic\n(and thus network) area.\nHowever, publish/subscribe systems that do span a wide \ngeographic area are likely to also span multiple administrative\ndomains, be they independent administrative domains inside\na single organisation, multiple independent organisations, or\na combination of the two.\nWhile the communication capabilities of publish/subscribe\nsystems are well proved, spanning multiple administrative\ndomains is likely to require addressing security \nconsiderations. As security and access control are almost the \nantithesis of decoupling, relatively little publish/subscribe research\nhas focused on security so far.\nOur overall research aim is to develop Internet-scale \npublish/subscribe networks that provide secure, efficient \ndelivery of events, fault-tolerance and self-healing in the delivery\ninfrastructure, and a convenient event interface.\nIn [12] Pesonen et al. propose a multi-domain, \ncapabilitybased access control architecture for publish/subscribe \nsystems. The architecture provides a mechanism for \nauthorising event clients to publish and subscribe to event types.\nThe privileges of the client are checked by the local broker\nthat the client connects to in order to access the publish/\nsubscribe system. The approach implements access control\nat the edge of the broker network and assumes that all \nbrokers can be trusted to enforce the access control policies \ncorrectly. Any malicious, compromised or unauthorised broker\nis free to read and write any events that pass through it\non their way from the publishers to the subscribers. This\nmight be acceptable in a relatively small system deployed\ninside a single organisation, but it is not appropriate in a\nmulti-domain environment in which organisations share a\ncommon infrastructure.\nWe propose enforcing access control within the broker \nnetwork by encrypting event content, and that policy dictate\ncontrols over the necessary encryption keys. With encrypted\nevent content only those brokers that are authorised to \nac104\ncess the encryption keys are able to access the event content\n(i.e. publish, subscribe to, or filter). We effectively move\nthe enforcement of access control from the brokers to the\nencryption key managers.\nWe expect that access control would need to be enforced\nin a multi-domain publish/subscribe system when \nmultiple organisations form a shared publish/subscribe system\nyet run multiple independent applications. Access control\nmight also be needed when a single organisation consists\nof multiple sub-domains that deliver confidential data over\nthe organisation-wide publish/subscribe system. Both cases\nrequire access control because event delivery in a dynamic\npublish/subscribe infrastructure based on a shared broker\nnetwork may well lead to events being routed through \nunauthorised domains along their paths from publishers to \nsubscribers.\nThere are two particular benefits to sharing the publish/\nsubscribe infrastructure, both of which relate to the \nbroker network. First, sharing brokers will create a physically\nlarger network that will provide greater geographic reach.\nSecond, increasing the inter-connectivity of brokers will \nallow the publish/subscribe system to provide higher \nfaulttolerance.\nFigure 1 shows the multi-domain publish/subscribe network\nwe use as an example throughout this paper. It is based\non the United Kingdom Police Forces, and we show three\nparticular sub-domains:\nMetropolitan Police Domain. This domain contains a\nset of CCTV cameras that publish information about\nthe movements of vehicles around the London area.\nWe have included Detective Smith as a subscriber in\nthis domain.\nCongestion Charge Service Domain. The charges that\nare levied on the vehicles that have passed through the\nLondon Congestion Charge zone each day are issued\nby systems within this domain. The source \nnumberplate recognition data comes from the cameras in the\nMetropolitan Police Domain. The fact that the CCS\nare only authorised to read a subset of the vehicle event\ndata will exercise some of the key features of the \nenforceable publish/subscribe system access control \npresented in this paper.\nPITO Domain. The Police Information Technology \nOrganisation (PITO) is the centre from which Police data\nstandards are managed. It is the event type owner in\nthis particular scenario.\nEncryption protects the confidentiality of events should they\nbe transported through unauthorised domains. However \nencrypting whole events means unauthorised brokers cannot\nmake efficient routing decisions.\nOur approach is to apply encryption to the individual \nattributes of events. This way our multi-domain access \ncontrol policy works at a finer granularity - publishers and \nsubscribers may be authorised access to a subset of the available\nattributes. In cases where non-encrypted events are used\nfor routing, we can reduce the total number of events sent\nthrough the system without revealing the values of sensitive\nattributes.\nIn our example scenario, the Congestion Charge Service\nwould only be authorised to read the numberplate field of\nvehicle sightings - the location attribute would not be \ndecrypted. We thus preserve the privacy of motorists while\nstill allowing the CCS to do its job using the shared \npublish/subscribe infrastructure.\nLet us assume that a Metropolitan Police Service detective\nis investigating a crime and she is interested in sightings\nof a specific vehicle. The detective gets a court order that\nauthorises her to subscribe to numberplate events of the\nspecific numberplate related to her case.\nCurrent publish/subscribe access control systems enforce \nsecurity at the edge of the broker network where clients \nconnect to it. However this approach will often not be \nacceptable in Internet-scale systems. We propose enforcing \nsecurity within the broker network as well as at the edges that\nevent clients connect to, by encrypting event content. \nPublications will be encrypted with their event type specific \nencryption keys. By controlling access to the encryption keys,\nwe can control access to the event types. The proposed \napproach allows event brokers to route events even when they\nhave access only to a subset of the potential encryption keys.\nWe introduce decentralised publish/subscribe systems and\nrelevant cryptography in Section 2. In Section 3 we present\nour model for encrypting event content on both the event\nand the attribute level. Section 4 discusses managing \nencryption keys in multi-domain publish/subscribe systems.\nWe analytically evaluate the performance of our proposal\nin Section 5. Finally Section 6 discusses related work in\nsecuring publish/subscribe systems and Section 7 provides\nconcluding remarks.\n2. BACKGROUND\nIn this section we provide a brief introduction to \ndecentralised publish/subscribe systems. We indicate our \nassumptions about multi-domain publish/subscribe systems, and\ndescribe how these assumptions influence the developments\nwe have made from our previously published work.\n2.1 Decentralised Publish/Subscribe Systems\nA publish/subscribe system includes publishers, subscribers,\nand an event service. Publishers publish events, subscribers\nsubscribe to events of interest to them, and the event \nservice is responsible for delivering published events to all \nsubscribers whose interests match the given event.\nThe event service in a decentralised publish/subscribe \nsystem is distributed over a number of broker nodes. Together\nthese brokers form a network that is responsible for \nmaintaining the necessary routing paths from publishers to \nsubscribers. Clients (publishers and subscribers) connect to a\nlocal broker, which is fully trusted by the client. In our \ndiscussion we refer to the client hosting brokers as publisher\nhosting brokers (PHB) or subscriber hosting brokers (SHB)\ndepending on whether the connected client is a publisher or\n105\nIB\nSHB\nSub\nPub\nPub\nSub\nSub\nIB\nPHB\nIB\nIB\nPHB\nIB\nIB\nIB\nIB SHB\nSHB\nIBIB\nIB\nIB\nIB\nIB\nIB\nIBIB\nIB\nTO\nIB\nIB\nIB\nMetropolitan Police\nDomain\nCongestion Charge\nService Domain\nPITO Domain\nDetective\nSmith\nCamera 1\nCamera 2\nBilling\nOffice Statistics\nOffice\nSub Subscriber SHB Subscriber\nHosting Broker\nPub Publisher PHB Publisher\nHosting Broker\nTO Type Owner IB Intermediate\nBroker\nKEY\nFigure 1: An overall view of our multi-domain publish/subscribe deployment\na subscriber, respectively. A local broker is usually either\npart of the same domain as the client, or it is owned by a\nservice provider trusted by the client.\nA broker network can have a static topology (e.g. Siena [3]\nand Gryphon [14]) or a dynamic topology (e.g. Scribe [4]\nand Hermes [13]). Our proposed approach will work in both\ncases. A static topology enables the system administrator\nto build trusted domains and in that way improve the \nefficiency of routing by avoiding unnecessary encryptions (see\nSect. 3.4), which is very difficult with a dynamic topology.\nOn the other hand, a dynamic topology allows the broker\nnetwork to dynamically re-balance itself when brokers join\nor leave the network either in a controlled fashion or as a\nresult of a network or node failure.\nOur work is based on the Hermes system. Hermes is a\ncontent-based publish/subscribe middleware that includes\nstrong event type support. In other words, each publication\nis an instance of a particular predefined event type. \nPublications are type checked at the local broker of each publisher.\nOur attribute level encryption scheme assumes that events\nare typed. Hermes uses a structured overlay network as a\ntransport and therefore has a dynamic topology.\nA Hermes publication consists of an event type identifier\nand a set of attribute value pairs. The type identifier is the\nSHA-1 hash of the name of the event type. It is used to\nroute the publication through the event broker network. It\nconveniently hides the type of the publication, i.e. brokers\nare prevented from seeing which events are flowing through\nthem unless they are aware of the specific event type name\nand identifier.\n2.2 Secure Event Types\nPesonen et al. introduced secure event types in [11], which\ncan have their integrity and authenticity confirmed by \nchecking their digital signatures. A useful side effect of secure\nevent types are their globally unique event type and \nattribute names. These names can be referred to by access\ncontrol policies. In this paper we use the secure name of the\nevent type or attribute to refer to the encryption key used\nto encrypt the event or attribute.\n2.3 Capability-Based Access Control\nPesonen et al. proposed a capability-based access control\narchitecture for multi-domain publish/subscribe systems in\n[12]. The model treats event types as resources that \npublishers, subscribers, and event brokers want to access. The\nevent type owner is responsible for managing access control\nfor an event type by issuing Simple Public Key \nInfrastructure (SPKI) authorisation certificates that grant the holder\naccess to the specified event type. For example, authorised\npublishers will have been issued an authorisation certificate\nthat specifies that the publisher, identified by public key, is\nauthorised to publish instances of the event type specified\nin the certificate.\nWe leverage the above mentioned access control mechanism\nin this paper by controlling access to encryption keys using\nthe same authorisation certificates. That is, a publisher who\nis authorised to publish a given event type, is also authorised\n106\nto access the encryption keys used to protect events of that\ntype. We discuss this in more detail in Sect. 4.\n2.4 Threat model\nThe goal of the proposed mechanism is to enforce access\ncontrol for authorised participants in the system. In our\ncase the first level of access control is applied when the \nparticipant tries to join the publish/subscribe network. \nUnauthorised event brokers are not allowed to join the broker\nnetwork. Similarly unauthorised event clients are not \nallowed to connect to an event broker. All the connections in\nthe broker network between event brokers and event clients\nutilise Transport Layer Security (TLS) [5] in order to \nprevent unauthorised access on the transport layer.\nThe architecture of the publish/subscribe system means that\nevent clients must connect to event brokers in order to be\nable to access the publish/subscribe system. Thus we \nassume that these clients are not a threat. The event client\nrelies completely on the local event broker for access to the\nbroker network. Therefore the event client is unable to \naccess any events without the assistance of the local broker.\nThe brokers on the other hand are able to analyse all events\nin the system that pass through them. A broker can \nanalyse both the event traffic as well as the number and names\nof attributes that are populated in an event (in the case of\nattribute level encryption). There are viable approaches to\npreventing traffic analysis by inserting random events into\nthe event stream in order to produce a uniform traffic \npattern. Similarly attribute content can be padded to a \nstandard length in order to avoid leaking information to the\nadversary.\nWhile traffic analysis is an important concern we have not\naddressed it further in this paper.\n3. ENCRYPTING EVENT CONTENT\nWe propose enforcing access control in a decentralised broker\nnetwork by encrypting the contents of published events and\ncontrolling access to the encryption keys. Effectively we\nmove the responsibility for access control from the broker\nnetwork to the key managers.\nIt is assumed that all clients have access to a broker that\nthey can trust and that is authorised to access the event \ncontent required by the client. This allows us to implement the\nevent content encryption within the broker network without\ninvolving the clients. By delegating the encryption tasks\nto the brokers, we lower the number of nodes required to\nhave access to a given encryption key1\n. The benefits are\nthree-fold: i) fewer nodes handle the confidential encryption\nkey so there is a smaller chance of the key being disclosed;\nii) key refreshes involve fewer nodes which means that the\nkey management algorithm will incur smaller \ncommunication and processing overheads to the publish/subscribe \nsystem; and iii) the local broker will decrypt an event once\nand deliver it to all subscribers, instead of each subscriber\n1\nThe encryption keys are changed over time in response to\nbrokers joining or leaving the network, and periodically to\nreduce the amount of time any single key is used. This is\ndiscussed in Sect. 4.2\nhaving to decrypt the same event. Delegating encryption\ntasks to the local broker is appropriate, because encryption\nis a middleware feature used to enforce access control within\nthe middleware system. If applications need to handle \nencrypted data in the application layer, they are free to publish\nencrypted data over the publish/subscribe system.\nWe can implement encryption either at the event level or\nthe attribute level. Event encryption is simpler, requires\nfewer keys, fewer independent cryptographic operations, and\nthus is usually faster. Attribute encryption enables access\ncontrol at the attribute level, which means that we have\na more expressive and powerful access control mechanism,\nwhile usually incurring a larger performance penalty.\nIn this section we discuss encrypting event content both at\nthe event level and the attribute level; avoiding leaking \ninformation to unauthorised brokers by encrypting \nsubscription filters; avoiding unnecessary encryptions between \nauthorised brokers; and finally, how event content encryption\nwas implemented in our prototype. Note that since no \npublish/subscribe client is ever given access to encryption keys,\nany encryption performed by the brokers is necessarily \ncompletely transparent to all clients.\n3.1 Event Encryption\nIn event encryption all the event attributes are encrypted as\na single block of plaintext. The event type identifier is left\nintact (i.e. in plaintext) in order to facilitate event routing\nin the broker network.\nThe globally unique event type identifier specifies the \nencryption key used to encrypt the event content. Each event\ntype in the system will have its own individual encryption\nkey. Keys are refreshed, as discussed in Sect. 4.2.\nWhile in transit the event will consist of a tuple \ncontaining the type identifier, a publication timestamp, ciphertext,\nand a message authentication tag: <type id, timestamp,\ncipher text, authentication tag>.\nEvent brokers that are authorised to access the event, and\nthus have access to the encryption key, can decrypt the event\nand implement content-based routing. Event brokers that\ndo not have access to the encryption key will be forced to\nroute the event based only on its type. That is, they will not\nbe able to make intelligent decisions about whether events\nneed not be transmitted down their outgoing links.\nEvent encryption results in one encryption at the publisher\nhosting broker, and one decryption at each filtering \nintermediate broker and subscriber hosting broker that the event\npasses through, regardless of the number of attributes. This\nresults in a significant performance advantage compared to\nattribute encryption.\n3.2 Attribute Encryption\nIn attribute encryption each attribute value in an event is \nencrypted separately with its own encryption key. The \nencryption key is identified by the attribute\"s globally unique \nidentifier (the globally unique event identifier defines a \nnamespace inside which the attribute identifier is a fully qualified\nname).\n107\nThe event type identifier is left intact to facilitate event \nrouting for unauthorised brokers. The attribute identifiers are\nalso left intact to allow authorised brokers to decrypt the\nattribute values with the correct keys. Brokers that are \nauthorised to access some of the attributes in an event, can\nimplement content-based routing over the attributes that\nare accessible to them.\nAn attribute encrypted event in transit consists of the event\ntype identifier, a publication timestamp, and a set of \nattribute tuples: <type id, timestamp, attributes >. \nAttribute tuples consist of an attribute identifier, ciphertext,\nand a message authentication tag: <attr id, ciphertext,\nauthentication tag>. The attribute identifier is the SHA-1\nhash of the attribute name used in the event type definition.\nUsing the attribute identifier in the published event instead\nof the attribute name prevents unauthorised parties from\nlearning which attributes are included in the publication.\nCompared with event encryption, attribute encryption \nusually results in larger processing overheads, because each \nattribute is encrypted separately. In the encryption process\nthe initialisation of the encryption algorithm takes a \nsignificant portion of the total running time of the algorithm.\nOnce the algorithm is initialised, increasing the amount of\ndata to be encrypted does not affect the running time very\nmuch. This disparity is emphasised in attribute \nencryption, where an encryption algorithm must be initialised for\neach attribute separately, and the amount of data encrypted\nis relatively small. As a result attribute encryption incurs\nlarger processing overheads when compared with event \nencryption which can be clearly seen from the performance\nresults in Sect. 5.\nThe advantage of attribute encryption is that the type owner\nis able to control access to the event type at the attribute\nlevel. The event type owner can therefore allow clients to\nhave different levels of access to the same event type. Also,\nattribute level encryption enables content-based routing in\ncases where an intermediate broker has access only to some\nof the attributes of the event, thus reducing the overall \nimpact of event delivery on the broker network. Therefore the\nchoice between event and attribute encryption is a trade-off\nbetween expressiveness and performance, and depends on\nthe requirements of the distributed application.\nThe expressiveness provided by attribute encryption can be\nemulated by introducing a new event type for each group\nof subscribers with the same authorisation. The publisher\nwould then publish an instance of each of these types \ninstead of publishing just a combined event. For example, in\nour London police network, the congestion control cameras\nwould have to publish one event for the CCS and another for\nthe detective. This approach could become difficult to \nmanage if the attributes have a variety of security properties,\nsince a large number of event types would be required and\npolicies and subscriptions may change dynamically. This\napproach creates a large number of extra events that must\nbe routed through the network, as is shown in Sect. 5.3.\n3.3 Encrypting Subscriptions\nIn order to fully protect the confidentiality of event content\nwe must also encrypt subscriptions. Encrypted \nsubscriptions guarantee: i) that only authorised brokers are able\nto submit subscriptions to the broker network, and ii) that\nunauthorised brokers do not gain information about event\ncontent by monitoring which subscriptions a given event\nmatches. For example, in the first case an unauthorised\nbroker can create subscriptions with appropriately chosen\nfilters, route them towards the root of the event \ndissemination tree, and monitor which events were delivered to it as\nmatching the subscription. The fact that the event matched\nthe subscription would leak information to the broker about\nthe event content even if the event was still encrypted. In\nthe second case, even if an unauthorised broker was unable\nto create subscriptions itself, it could still look at \nsubscriptions that were routed through it, take note of the filters on\nthose subscriptions, and monitor which events are delivered\nto it by upstream brokers as matching the subscription \nfilters. This would again reveal information about the event\ncontent to the unauthorised broker.\nIn the case of encrypting complete events, we also encrypt\nthe complete subscription filter. The event type identifier in\nthe subscription must be left intact to allow brokers to route\nevents based on their topic when they are not authorised to\naccess the filter. In such cases the unauthorised broker is\nrequired to assume that events of such a type match all\nfilter expressions.\nEach attribute filter is encrypted individually, much as when\nencrypting a publication. In addition to the event type \nidentifier the attribute identifiers are also left intact to allow\nauthorised brokers to decrypt those filters that they have\naccess to, and route the event based on its matching the\ndecrypted filters.\n3.4 Avoiding Unnecessary Cryptographic \nOperations\nEncrypting the event content is not necessary if the current\nbroker and the next broker down the event dissemination\ntree have the same credentials with respect to the event\ntype at hand. For example, one can assume that all \nbrokers inside an organisation would share the same credentials\nand therefore, as long as the next broker is a member of\nthe same domain, the event can be routed to it in plaintext.\nWith attribute encryption it is possible that the \nneighbouring broker is authorised to access a subset of the decrypted\nattributes, in which case those attributes that the broker is\nnot authorised to access would be passed to it encrypted.\nIn order to know when it is safe to pass the event in plaintext\nform, the brokers exchange credentials as part of a \nhandshake when they connect to each other. In cases when the\nbrokers are able to verify each others\" credentials, they will\nadd them to the routing table for future reference. If a \nbroker acquires new credentials after the initial handshake, it\nwill present these new credentials to its neighbours while in\nsession.\nRegardless of its neighbouring brokers, the PHB will always\nencrypt the event content, because it is cheaper to encrypt\nthe event once at the root of the event dissemination tree.\nIn Hermes the rendezvous node for each event type is \nselected uniformly randomly (the event type name is hashed\nwith the SHA-1 hash algorithm to produce the event type\n108\nPHB\nIBIB\nIB SHB\nRN IB\nSHB\nFigure 2: Node addressing is evenly distributed\nacross the network, thus rendezvous nodes may lie\noutside the domain that owns an event type\nIB IB SHBPHBP S\nEncrypts Filters from\ncache\nDecrypts,\ndelivers\nDecrypts,\nfilters\nPlaintext\nCached Plaintext (most data)\nCached Plaintext (some data)\nDifferent domains\nCyphertext\nKEY\nFigure 3: Caching decrypted data to increase \nefficiency when delivering to peers with equivalent \nsecurity privileges\nidentifier, then the identifier is used to select the rendezvous\nnode in the structured overlay network). Therefore it is\nprobable that the rendezvous node will reside outside the\ncurrent domain. This situation is illustrated in the event\ndissemination tree in Fig. 2. So even with domain internal\napplications, where the event can be routed from the \npublisher to all subscribers in plaintext form, the event content\nwill in most cases have to be encrypted for it to be routed\nto the rendezvous node.\nTo avoid unnecessary decryptions, we attach a plaintext \ncontent cache to encrypted events. A broker fills the cache with\ncontent that it has decrypted, for example, in order to filter\non the content. The cache is accessed by the broker when\nit delivers an event to a local subscriber after first seeing if\nthe event matches the subscription filter, but the broker also\nsends the cache to the next broker with the encrypted event.\nThe next broker can look the attribute up from the cache\ninstead of having to decrypt it. If the event is being sent to\nan unauthorised broker, the cache will be discarded before\nthe event is sent. Obviously sending the cache with the \nencrypted event will add to the communication cost, but this is\noutweighed by the saving in encryption/decryption \nprocessing. In Fig. 3 we see two separate cached plaintext streams\naccompanying an event depending on the inter-broker \nrelationships in two different domains.\nWe show in Sect. 5.2 that the overhead of sending encrypted\nmessages with a full plaintext cache incurs almost no \noverhead compared to sending plaintext messages.\n3.5 Implementation\nIn our implementation we have used the EAX mode [2] of \noperation when encrypting events, attributes, and subscription\nfilters. EAX is a mode of operation for block ciphers, also\ncalled an Authenticated Encryption with Associated Data\n(AEAD) algorithm that provides simultaneously both data\nconfidentiality and integrity protection. The algorithm \nimplements a two-pass scheme where during the first pass the\nplain text is encrypted, and on the second pass a message\nauthentication code (MAC) is generated for the encrypted\ndata.\nThe EAX mode is compatible with any block cipher. We\ndecided to use the Advanced Encryption Standard (AES) [9]\nalgorithm in our implementation, because of its standard\nstatus and the fact that the algorithm has gone through\nthorough cryptanalysis during its existence and no serious\nvulnerabilities have been found thus far.\nIn addition to providing both confidentiality and integrity\nprotection, the EAX mode uses the underlying block cipher\nin counter mode (CTR mode) [21]. A block cipher in counter\nmode is used to produce a stream of key bits that are then\nXORed with the plaintext. Effectively CTR mode \ntransforms a block cipher into a stream cipher. The advantage of\nstream ciphers is that the ciphertext is the same length as\nthe plaintext, whereas with block ciphers the plaintext must\nbe padded to a multiple of the block cipher\"s block length\n(e.g. the AES block size is 128 bits). Avoiding padding is\nvery important in attribute encryption, because the padding\nmight increase the size of the attribute disproportionally.\nFor example, a single integer might be 32 bits in length,\nwhich would be padded to 128 bits if we used a block \ncipher. With event encryption the message expansion is not\nthat relevant, since the length of padding required to reach\nthe next 16 byte multiple will probably be a small \nproportion of the overall plaintext length.\nIn encryption mode the EAX algorithm takes as input a\nnonce (a number used once), an encryption key and the\nplaintext, and it returns the ciphertext and an \nauthentication tag. In decryption mode the algorithm takes as input\nthe encryption key, the ciphertext and the authentication\ntag, and it returns either the plaintext, or an error if the\nauthentication check failed.\nThe nonce is expanded to the block length of the \nunderlying block cipher by passing it through an OMAC construct\n(see [7]). It is important that particular nonce values are\nnot reused, otherwise the block cipher in CTR mode would\nproduce an identical key stream. In our implementation we\nused the PHB defined event timestamp (64-bit value \ncounting the milliseconds since January 1, 1970 UTC) appended\nby the PHB\"s identity (i.e. public key) as the nonce. The\nbroker is responsible for ensuring that the timestamps \nincrease monotonically.\nThe authentication tag is appended to the produced cipher\ntext to create a two-tuple. With event encryption a \nsingle tag is created for the encrypted event. With attribute\n109\nencryption each attribute is encrypted and authenticated\nseparately, and they all have their individual tags. The tag\nlength is configurable in EAX without restrictions, which\nallows the user to make a trade-off between the \nauthenticity guarantees provided by EAX and the added \ncommunication overhead. We used a tag length of 16 bytes\nin our implementation, but one could make the tag length\na publisher/subscriber defined parameter for each \npublication/subscription or include it in the event type definition\nto make it a type specific parameter.\nEAX also supports including unencrypted associated data in\nthe tag calculation. The integrity of this data is protected,\nbut it is still readable by everyone. This feature could be\nused with event encryption in cases where some of the event\ncontent is public and thus would be useful for content-based\nrouting. The integrity of the data would still be protected\nagainst changes, but unauthorised brokers would be able to\napply filters. We have included the event type identifier as\nassociated data in order to protect its integrity.\nOther AEAD algorithms include the offset codebook mode\n(OCB) [17] and the counter with CBC-MAC mode (CCM)\n[22]. Contrarily to the EAX mode the OCB mode requires\nonly one pass over the plaintext, which makes it roughly\ntwice as fast as EAX. Unfortunately the OCB mode has a\npatent application in place in the USA, which restricts its\nuse. The CCM mode is the predecessor of the EAX mode.\nIt was developed in order to provide a free alternative to\nOCB. The EAX was developed later to address some issues\nwith CCM [18]. Similarly to EAX, CCM is also a two-pass\nmode.\n4. KEY MANAGEMENT\nIn both encryption approaches the encrypted event content\nhas a globally unique identifier (i.e. the event type or the\nattribute identifier). That identifier is used to determine\nthe encryption key to use when encrypting or decrypting\nthe content. Each event type, in event encryption, and \nattribute, in attribute encryption, has its own individual \nencryption key. By controlling access to the encryption key we\neffectively control access to the encrypted event content.\nIn order to control access to the encryption keys we form a\nkey group of brokers for each individual encryption key. The\nkey group is used to refresh the key when necessary and to\ndeliver the new key to all current members of the key group.\nThe key group manager is responsible for verifying that a\nnew member requesting to join the key group is authorised\nto do so. Therefore the key group manager must be trusted\nby the type owner to enforce the access control policy. We\nassume that the key group manager is either a trusted third\nparty or alternatively a member of the type owner\"s domain.\nIn [12] Pesonen et al. proposed a capability-based access\ncontrol architecture for multi-domain publish/subscribe \nsystems. The approach uses capabilities to decentralise the\naccess control policy amongst the publish/subscribe nodes\n(i.e. clients and brokers): each node holds a set of \ncapabilities that define the authority granted to that node. \nAuthority to access a given event type is granted by the owner\nof that type issuing a capability to a node. The capability\ndefines the event type, the action, and the attributes that\nType Owner\nACS\nBroker\nKey Manager\n1.Grant authorisation\nfor Number Platekey\n2.Broker requests to\njoin Number Plate\nkey group\n5.If the broker satisfies\nall checks,they will begin\nreceiving appropriate keys.\n3.Key manager may check\nbroker\"s credentials at the\nAccess Control Service\n4.Key manager may\ncheck that the Type\nOwner permits access\nFigure 4: The steps involved for a broker to be \nsuccessful in joining a key group\nthe node is authorised to access. For example, a tuple <NP,\nsubscribe, *> would authorise the owner to subscribe to\nNumberplate events with access to all attributes in the \npublished events. The sequence of events required for a broker\nto successfully join a key group is shown in Fig. 4.\nBoth the client hosting broker and the client must be \nauthorised to make the client\"s request. That is, if the client\nmakes a subscription request for Numberplate events, both\nthe client and the local broker must be authorised to \nsubscribe to Numberplate events. This is because from the \nperspective of the broker network, the local broker acts as a\nproxy for the client.\nWe use the same capabilities to authorise membership in a\nkey group that are used to authorise publish/subscribe \nrequests. Not doing so could lead to the inconsistent situation\nwhere a SHB is authorised to make a subscription on behalf\nof its clients, but is not able to decrypt incoming event \ncontent for them. In the Numberplate example above, the local\nbroker holding the above capability is authorised to join the\nNumberplate key group as well as the key groups for all the\nattributes in the Numberplate event type.\n4.1 Secure Group Communication\nEvent content encryption in a decentralised multi-domain\npublish/subscribe system can be seen as a sub-category of\nsecure group communication. In both cases the key \nmanagement system must scale well with the number of clients,\nclients might be spread over large geographic areas, there\nmight be high rates of churn in group membership, and all\nmembers must be synchronised with each other in time in\norder to use the same encryption key at the same time.\nThere are a number of scalable key management protocols\nfor secure group communication [15]. We have implemented\nthe One-Way Function Tree (OFT) [8] protocol as a proof\nof concept. We chose to implement OFT, because of its\nrelatively simplicity and good performance. Our \nimplementation uses the same structured overlay network used by the\nbroker network as a transport. The OFT protocol is based\non a binary tree where the participants are at the leaves of\nthe tree. It scales in log2n in processing and \ncommunication costs, as well as in the size of the state stored at each\nparticipant, which we have verified in our simulations.\n4.2 Key Refreshing\nTraditionally in group key management schemes the \nencryption key is refreshed when a new member joins the group, an\n110\nexisting member leaves the group, or a timer expires. \nRefreshing the key when a new member joins provides \nbackward secrecy, i.e. the new member is prevented from \naccessing old messages. Similarly refreshing the key when an\nexisting member leaves provides forward secrecy, i.e. the old\nmember is prevented from accessing future messages. Timer\ntriggered refreshes are issued periodically in order to limit\nthe damage caused by the current key being compromised.\nEven though the state-of-the-art key management protocols\nare efficient, refreshing the key unnecessarily introduces \nextra traffic and processing amongst the key group members.\nIn our case key group membership is based on the broker\nholding a capability that authorises it to join the key group.\nThe capability has a set of validity conditions that in their\nsimplest form define a time period when the certificate is\nvalid, and in more complex cases involve on-line checks back\ntowards the issuer. In order to avoid unnecessary key \nrefreshes the key manager looks at the certificate validity \nconditions of the joining or leaving member. In case of a joining\nmember, if the manager can ascertain that the certificate\nwas valid at the time of the previous key refresh, a new\nkey refresh can be avoided. Similarly, instead of refreshing\nthe key immediately when a member leaves the key group,\nthe key manager can cache their credentials and refresh the\nkey only when the credentials expire. These situations are\nboth illustrated in Fig.5. It can be assumed that the \ncredentials granted to brokers are relatively static, i.e. once a\ndomain is authorised to access an event type, the authority\nwill be delegated to all brokers of that domain, and they\nwill have the authority for the foreseeable future. More fine\ngrained and dynamic access control would be implemented\nat the edge of the broker network between the clients and\nthe client hosting brokers.\nWhen an encryption key is refreshed the new key is tagged\nwith a timestamp. The encryption key to use for a given\nevent is selected based on the event\"s publication timestamp.\nThe old keys will be kept for a reasonable amount of time\nin order to allow for some clock drift. Setting this value is\npart of the key management protocol, although exactly how\nlong this time should be will depend on the nature of the\napplication and possibly the size of the network. It can be\nconfigured independently per key group if necessary.\n5. EVALUATION\nIn order to evaluate the performance of event content \nencryption we have implemented both encryption approaches\nrunning over our implementation of the Hermes publish/\nsubscribe middleware. The implementation supports three\nmodes: plaintext content, event encryption, and attribute\nencryption, in a single publish/subscribe system.\nWe ran three performance tests in a discrete event simulator.\nThe simulator was run on an Intel P4 3.2GHz workstation\nwith 1GB of main memory. We decided to run the tests on\nan event simulator instead of an actual deployed system in\norder to be able to measure to aggregate time it takes to\nhandle all messages in the system.\nThe following sections describe the specific test setups and\nthe results in more detail.\n5.1 End-to-End Overhead\nThe end-to-end overhead test shows how much the overall\nmessage throughput of the simulator was affected by event\ncontent encryption. We formed a broker network with two\nbrokers, attached a publisher to one of them and a \nsubscriber to the other one. The subscriber subscribed to the\nadvertised event type without any filters, i.e. each \npublication matched the subscriber\"s publication and thus was\ndelivered to the subscriber. The test measures the \ncombined time it takes to publish and deliver 100,000 events. If\nthe content is encrypted this includes both encrypting the\ncontent at the PHB and decrypting it at the SHB.\nIn the test the number of attributes in the event type is\nincreased from 1 to 25 (the x-axis). Each attribute is set\nto a 30 character string. For each number of attributes in\nthe event type the publisher publishes 100,000 events, and\nthe elapsed time is measured to derive the message \nthroughput. The test was repeated five times for each number of\nattributes and we use the average of all iterations in the\ngraph, but the results were highly consistent so the \nstandard deviation is not shown. The same tests were run with\nno content encryption, event encryption, and attribute \nencryption.\nAs can be seen in Fig. 6, event content encryption introduces\na large overhead compared to not using encryption. The\nthroughput when using attribute encryption with an event\ntype with one attribute is 46% of the throughput achieved\nwhen events are sent in plaintext. When the number of\nattributes increases the performance gap increases as well:\nwith ten attributes the performance with attribute \nencryption has decreased to 11.7% of plaintext performance.\nEvent encryption fares better, because of fewer encryption\noperations. The increase in the amount of encrypted data\ndoes not affect the performance as much as the number of\nindividual encryption operations does. The difference in\nperformance with event encryption and attribute \nencryption with only one attribute is caused by the Java object\nserialisation mechanism: in the event encryption case the\nwhole attribute structure is serialised, which results in more\nobjects than serialising a single attribute value. A more \nefficient implementation would provide its own marshalling\nmechanism.\nNote that the EAX implementation we use runs the nonce\n(i.e. initialisation vector) through an OMAC construct to\nincrease its randomness. Since the nonce is not required to\nbe kept secret (just unique), there is a potential time/space\ntrade-off we have not yet investigated in attaching extra\nnonce attributes that have already had this OMAC \nconstruct applied to them.\n5.2 Domain Internal Events\nWe explained in Sect. 3.4 that event content decryption and\nencryption can be avoided if both brokers are authorised to\naccess the event content. This test was designed to show\nthat the use of the encrypted event content mechanism \nbetween two authorised brokers incurs only a small \nperformance overhead.\nIn this test we again form a broker network with two brokers.\n111\nKey refresh schedule\nBroker 1 joining and\nleaving the key group\nBroker 2 joining and\nleaving the key group\nActual key refresh times\nTime\nOne day\nBroker\"s key group\ncredentials are valid\nActual join time Actual leave time\nOne day One day\nFigure 5: How the key refresh schedule is affected by brokers joining and leaving key groups\n0\n5000\n10000\n15000\n20000\n25000\n30000\n35000\n0 5 10 15 20 25\nMessagesperSecond\nNumber of Attributes\nNo Encryption\nAttribute Encryption\nWhole-content Encryption\nFigure 6: Throughput of Events in a Simulator\nBoth brokers are configured with the same credentials. The\npublisher is attached to one of the brokers and the subscriber\nto the other, and again the subscriber does not specify any\nfilters in its subscription.\nThe publisher publishes 100,000 events and the test \nmeasures the elapsed time in order to derive the system\"s \nmessage throughput. The event content is encrypted outside the\ntiming measurement, i.e. the encryption cost is not included\nin the measurements. The goal is to model an environment\nwhere a broker has received a message from another \nauthorised broker, and it routes the event to a third authorised\nbroker. In this scenario the middle broker does not need to\ndecrypt nor encrypt the event content.\nAs shown in Fig. 2, the elapsed time was measured as the\nnumber of attributes in the published event was increased\nfrom 1 to 25. The attribute values in each case are 30 \ncharacter strings. Each test is repeated five times, and we use\nthe average of all iterations in the graph. The same test was\nthen repeated with no encryption, event encryption and \nattribute encryption turned on.\nThe encrypted modes follow each other very closely. \nPredictably, the plaintext mode performs a little better for all\nattribute counts. The difference can be explained partially\nby the encrypted events being larger in size, because they\ninclude both the plaintext and the encrypted content in this\ntest. The difference in performance is 3.7% with one \nattribute and 2.5% with 25 attributes.\nWe believe that the roughness of the graphs can be explained\nby the Java garbage collector interfering with the simulation.\nThe fact that all three graphs show the same irregularities\nsupports this theory.\n112\n50000\n55000\n60000\n65000\n70000\n75000\n80000\n85000\n90000\n95000\n100000\n0 5 10 15 20 25\nMessagesperSecond\nNumber of Attributes\nNo Encryption\nAttribute Encryption\nWhole-content Encryption\nFigure 7: Throughput of Domain Internal Events\n5.3 Communication Overhead\nThrough the definition of multiple event types, it is possible\nto emulate the expressiveness of attribute encryption using\nonly event content encryption. The last test we ran was to\nshow the communication overhead caused by this emulation\ntechnique, compared to using real attribute encryption.\nIn the test we form a broker network of 2000 brokers. We\nattach one publisher to one of the brokers, and an \nincreasing number of subscribers to the remaining brokers. Each\nsubscriber simulates a group of subscribers that all have the\nsame access rights to the published event. Each subscriber\ngroup has its own event type in the test.\nThe outcome of this test is shown in Fig. 8. The number\nof subscriber groups is increased from 1 to 50 (the x-axis).\nFor each n subscriber groups the publisher publishes one\nevent to represent the use of attribute encryption and n\nevents representing the events for each subscriber group. We\ncount the number of hops each publication makes through\nthe broker network (y-axis).\nNote that Fig. 8 shows workloads beyond what we would\nexpect in common usage, in which many event types are\nlikely to contain fewer than ten attributes. The subscriber\ngroups used in this test represent disjoint permission sets\nover such event attributes. The number of these sets can be\ndetermined from the particular access control policy in use,\nbut will be a value less than or equal to the factorial of the\nnumber of attributes in a given event type.\nThe graphs indicate that attribute encryption performs \nbetter than event encryption even for small numbers of \nsubscriber groups. Indeed, with only two subscriber groups\n(e.g. the case with Numberplate events) the hop count \nincreases from 7.2 hops for attribute encryption to 16.6 hops\nfor event encryption. With 10 subscriber groups the \ncorresponding numbers are 24.2 and 251.0, i.e. an order of \nmagnitude difference.\n6. RELATED WORK\nWang et al. have categorised the various security issues that\nneed to be addressed in publish/subscribe systems in the\nfuture in [20]. The paper is a comprehensive overview of \nsecurity issues in publish/subscribe systems and as such tries\nto draw attention to the issues rather than providing \nsolutions.\nBacon et al. in [1] examine the use of role-based access \ncontrol in multi-domain, distributed publish/subscribe systems.\nTheir work is complementary to this paper: distributed\nRBAC is one potential policy formalism that might use the\nenforcement mechanisms we have presented.\nOpyrchal and Prakash address the problem of event \nconfidentiality at the last link between the subscriber and the\nSHB in [10]. They correctly state that a secure group \ncommunication approach is infeasible in an environment like\npublish/subscribe that has highly dynamic group \nmemberships. As a solution they propose a scheme utilising key\ncaching and subscriber grouping in order to minimise the\nnumber of required encryptions when delivering a \npublication from a SHB to a set of matching subscribers. We \nassume in our work that the SHB is powerful enough to \nman113\n1\n10\n100\n1000\n10000\n0 5 10 15 20 25 30 35 40 45 50\nNumberofHopsinTotal\nNumber of Subscription Groups\nAttribute Encryption\nWhole-content Encryption\nFigure 8: Hop Counts When Emulating Attribute Encryption\nage a TLS secured connection for each local subscriber.\nBoth Srivatsa et al. [19] and Raiciu et al. [16] present \nmechanisms for protecting the confidentiality of messages in \ndecentralised publish/subscribe infrastructures. Compared to\nour work both papers aim to provide the means for \nprotecting the integrity and confidentiality of messages whereas the\ngoal for our work is to enforce access control inside the \nbroker network. Raiciu et al. assume in their work that none\nof the brokers in the network are trusted and therefore all\nevents are encrypted from publisher to subscriber and that\nall matching is based on encrypted events. In contrast, we\nassume that some of the brokers on the path of a \npublication are trusted to access that publication and are therefore\nable to implement event matching. We also assume that the\npublisher and subscriber hosting brokers are always trusted\nto access the publication. The contributions of Srivatsa et\nal. and Raiciu et al. are complementary to the contributions\nin this paper.\nFinally, Fiege et al. address the related topic of event \nvisibility in [6]. While the work concentrated on using scopes as\nmechanism for structuring large-scale event-based systems,\nthe notion of event visibility does resonate with access \ncontrol to some extent.\n7. CONCLUSIONS\nEvent content encryption can be used to enforce an access\ncontrol policy while events are in transit in the broker \nnetwork of a multi-domain publish/subscribe system. \nEncryption causes an overhead, but i) there may be no \nalternative when access control is required, and ii) the performance\npenalty can be lessened with implementation optimisations,\nsuch as passing cached plaintext content alongside encrypted\ncontent between brokers with identical security credentials.\nThis is particularly appropriate if broker-to-broker \nconnections are secured by default so that wire-sniffing is not an\nissue.\nAttribute level encryption can be implemented in order to\nenforce fine-grained access control policies. In addition to\nproviding attribute-level access control, attribute encryption\nenables partially authorised brokers to implement \ncontentbased routing based on the attributes that are accessible to\nthem.\nOur experiments show that i) by caching plaintext and \nciphertext content when possible, we are able to deliver \ncomparable performance to plaintext events, and ii) that \nattribute encryption within an event incurs far less overhead\nthan defining separate event types for the attributes that\nneed different levels of protection.\nIn environments comprising multiple domains, where \neventbrokers have different security credentials, we have \nquantified how a trade-off can be made between performance and\nexpressiveness.\nAcknowledgements\nWe would like to thank the anonymous reviewers for their\nvery helpful comments. Lauri Pesonen is supported by \nEPSRC (GR/T28164) and the Nokia Foundation. David Eyers\nis supported by EPSRC (GR/S94919).\n114\n8. REFERENCES\n[1] J. Bacon, D. M. Eyers, K. Moody, and L. I. W.\nPesonen. Securing publish/subscribe for multi-domain\nsystems. In G. Alonso, editor, Middleware, volume\n3790 of Lecture Notes in Computer Science, pages\n1-20. Springer, 2005.\n[2] M. Bellare, P. Rogaway, and D. Wagner. Eax: A\nconventional authenticated-encryption mode.\nCryptology ePrint Archive, Report 2003/069, 2003.\nhttp://eprint.iacr.org/.\n[3] A. Carzaniga, D. S. Rosenblum, and A. L. Wolf.\nDesign and evaluation of a wide-area event\nnotification service. ACM Transactions on Computer\nSystems, 19(3):332-383, Aug. 2001.\n[4] M. Castro, P. Druschel, A. Kermarrec, and\nA. Rowstron. SCRIBE: A large-scale and\ndecentralized application-level multicast\ninfrastructure. IEEE Journal on Selected Areas in\ncommunications (JSAC), 20(8):1489-1499, Oct. 2002.\n[5] T. Dierks and C. Allen. The TLS protocol, version\n1.0. RFC 2246, Internet Engineering Task Force, Jan.\n1999.\n[6] L. Fiege, M. Mezini, G. M uhl, and A. P. Buchmann.\nEngineering event-based systems with scopes. In\nECOOP \"02: Proceedings of the 16th European\nConference on Object-Oriented Programming, pages\n309-333, London, UK, 2002. Springer-Verlag.\n[7] T. Iwata and I. A. Iurosawa. OMAC: One-key CBC\nMAC, Jan. 14 2002.\n[8] D. A. McGrew and A. T. Sherman. Key establishment\nin large dynamic groups using one-way function trees.\nTechnical Report 0755, TIS Labs at Network\nAssociates, Inc., Glenwood, MD, May 1998.\n[9] National Institute of Standards and Technology\n(NIST). Advanced Encryption Standard (AES).\nFederal Information Processing Standards Publication\n(FIPS PUB) 197, Nov. 2001.\n[10] L. Opyrchal and A. Prakash. Secure distribution of\nevents in content-based publish subscribe systems. In\nProc. of the 10th USENIX Security Symposium.\nUSENIX, Aug. 2001.\n[11] L. I. W. Pesonen and J. Bacon. Secure event types in\ncontent-based, multi-domain publish/subscribe\nsystems. In SEM \"05: Proceedings of the 5th\ninternational workshop on Software engineering and\nmiddleware, pages 98-105, New York, NY, USA, Sept.\n2005. ACM Press.\n[12] L. I. W. Pesonen, D. M. Eyers, and J. Bacon. A\ncapabilities-based access control architecture for\nmulti-domain publish/subscribe systems. In\nProceedings of the Symposium on Applications and the\nInternet (SAINT 2006), pages 222-228, Phoenix, AZ,\nJan. 2006. IEEE.\n[13] P. R. Pietzuch and J. M. Bacon. Hermes: A\ndistributed event-based middleware architecture. In\nProc. of the 1st International Workshop on Distributed\nEvent-Based Systems (DEBS\"02), pages 611-618,\nVienna, Austria, July 2002. IEEE.\n[14] P. R. Pietzuch and S. Bhola. Congestion control in a\nreliable scalable message-oriented middleware. In\nM. Endler and D. Schmidt, editors, Proc. of the 4th\nInt. Conf. on Middleware (Middleware \"03), pages\n202-221, Rio de Janeiro, Brazil, June 2003. Springer.\n[15] S. Rafaeli and D. Hutchison. A survey of key\nmanagement for secure group communication. ACM\nComputing Surveys, 35(3):309-329, 2003.\n[16] C. Raiciu and D. S. Rosenblum. Enabling\nconfidentiality in content-based publish/subscribe\ninfrastructures. In Securecomm \"06: Proceedings of the\nSecond IEEE/CreatNet International Conference on\nSecurity and Privacy in Communication Networks,\n2006.\n[17] P. Rogaway, M. Bellare, J. Black, and T. Krovetz.\nOCB: a block-cipher mode of operation for efficient\nauthenticated encryption. In ACM Conference on\nComputer and Communications Security, pages\n196-205, 2001.\n[18] P. Rogaway and D. Wagner. A critique of CCM, Feb.\n2003.\n[19] M. Srivatsa and L. Liu. Securing publish-subscribe\noverlay services with eventguard. In CCS \"05:\nProceedings of the 12th ACM conference on Computer\nand communications security, pages 289-298, New\nYork, NY, USA, 2005. ACM Press.\n[20] C. Wang, A. Carzaniga, D. Evans, and A. L. Wolf.\nSecurity issues and requirements in internet-scale\npublish-subscribe systems. In Proc. of the 35th Annual\nHawaii International Conference on System Sciences\n(HICSS\"02), Big Island, HI, USA, 2002. IEEE.\n[21] D. Whitfield and M. Hellman. Privacy and\nauthentication: An introduction to cryptography. In\nProceedings of the IEEE, volume 67, pages 397-427,\n1979.\n[22] D. Whiting, R. Housley, and N. Ferguson. Counter\nwith CBC-MAC (CCM). RFC 3610, Internet\nEngineering Task Force, Sept. 2003.\n115\n": ["secure publish/subscribe system", "distributed access control", "multiple administrative domain", "attribute encryption", "multi-domain", "overall communication overhead", "distributed systems-distributed application", "performance", "encryption", "congestion charge service", "distribute access control", "administrative domain", ""]}