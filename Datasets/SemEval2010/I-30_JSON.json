{"Distributed Task Allocation in Social Networks\nMathijs de Weerdt\nDelft Technical University\nDelft, The Netherlands\nM.M.deWeerdt@tudelft.nl\nYingqian Zhang\nDelft Technical University\nDelft, The Netherlands\nYingqian.Zhang@tudelft.nl\nTomas Klos\nCenter for Mathematics and\nComputer Science (CWI)\nAmsterdam, The Netherlands\ntomas.klos@cwi.nl\nABSTRACT\nThis paper proposes a new variant of the task allocation\nproblem, where the agents are connected in a social network\nand tasks arrive at the agents distributed over the network.\nWe show that the complexity of this problem remains \nNPhard. Moreover, it is not approximable within some factor.\nWe develop an algorithm based on the contract-net \nprotocol. Our algorithm is completely distributed, and it assumes\nthat agents have only local knowledge about tasks and \nresources. We conduct a set of experiments to evaluate the\nperformance and scalability of the proposed algorithm in\nterms of solution quality and computation time. Three \ndifferent types of networks, namely small-world, random and\nscale-free networks, are used to represent various social \nrelationships among agents in realistic applications. The results\ndemonstrate that our algorithm works well and that it scales\nwell to large-scale applications.\nCategories and Subject Descriptors\nI.2.11 [Distributed Artificial Intelligence]: Multiagent\nsystems\nGeneral Terms\nAlgorithms, Experimentation\n1. INTRODUCTION\nRecent years have seen a lot of work on task and \nresource allocation methods, which can potentially be applied\nto many real-world applications. However, some interesting\napplications where relations between agents play a role \nrequire a slightly more general model. Such situations appear\nvery frequently in real-world scenarios, and recent \ntechnological developments are bringing more of them within the\nrange of task allocation methods. Especially in business \napplications, preferential partner selection and interaction is\nvery common, and this aspect becomes more important for\ntask allocation research, to the extent that technological \ndevelopments need to be able to support it.\nFor example, the development of semantic web and grid\ntechnologies leads to increased and renewed attention for\nthe potential of the web to support business processes [7,\n15]. As an example, virtual organizations (VOs) are \nbeing re-invented in the context of the grid, where they are\ncomposed of a number of autonomous entities (representing\ndifferent individuals, departments and organizations), each\nof which has a range of problem-solving capabilities and \nresources at its disposal [15, p. 237]. The question is how VOs\nare to be dynamically composed and re-composed from \nindividual agents, when different tasks and subtasks need to be\nperformed. This would be done by allocating them to \ndifferent agents who may each be capable of performing different\nsubsets of those tasks. Similarly, supply chain formation\n(SCF) is concerned with the, possibly ad-hoc, allocation of\nservices to providers in the supply chain, in such a way that\noverall profit is optimized [6, 21].\nTraditionally, such allocation decisions have been \nanalyzed using transaction cost economics (TCE) [4], which\ntakes the transaction between consecutive stages of \ndevelopment as its basic unit of analysis, and considers the firm\nand the market as alternative structural forms for \norganizing transactions. (Transaction cost) economics has \ntraditionally built on analysis of comparative statics: the central\nproblem of economic organization is considered to be the\nadaptation of organizational forms to the characteristics of\ntransactions. More recently, TCE\"s founding father, Ronald\nCoase, acknowledged that this is too simplistic an approach\n[5, p. 245]: The analysis cannot be confined to what \nhappens within a single firm. (. . . ) What we are dealing with\nis a complex interrelated structure.\nIn this paper, we study the problem of task allocation\nfrom the perspective of such a complex interrelated \nstructure. In particular, \u00e2\u20ac\u02dcthe market\" cannot be considered as an\norganizational form without considering specific partners to\ninteract with on the market [11]. Specifically, therefore, we\nconsider agents to be connected to each other in a social\nnetwork. Furthermore, this network is not fully connected:\nas informed by the business literature, firms typically have\nestablished working relations with limited numbers of \npreferred partners [10]; these are the ones they consider when\nnew tasks arrive and they have to form supply chains to \nallocate those tasks [19]. Other than modeling the interrelated\n500\n978-81-904262-7-5 (RPS) c 2007 IFAAMAS\nstructure between business partners, the social network \nintroduced in this paper can also be used to represent other\ntypes of connections or constraints among autonomous \nentities that arise from other application domains.\nThe next section gives a formal description of the task \nallocation problem on social networks. In Section 3, we prove\nthat the complexity of this problem remains NP-hard. We\nthen proceed to develop a distributed algorithm in Section 4,\nand perform a series of experiments with this algorithm, as\ndescribed in Section 5. Section 6 discusses related work, and\nSection 7 concludes.\n2. PROBLEM DESCRIPTION\nWe formulate the social task allocation problem in this\nsection. There is a set A of agents: A = {a1, . . . , am}.\nAgents need resources to complete tasks. Let R = {r1, . . . , rk}\ndenote the collection of the resource types available to the\nagents A. Each agent a \u00e2\u02c6\u02c6 A controls a fixed amount of \nresources for each resource type in R, which is defined by a\nresource function: rsc : A \u00c3\u2014 R \u00e2\u2020\u2019 N. Moreover, we assume\nagents are connected by a social network.\nDefinition 1 (Social network). An agent social \nnetwork SN = (A, AE) is an undirected graph, where vertices\nA are agents, and each edge (ai, aj) \u00e2\u02c6\u02c6 AE indicates the \nexistence of a social connection between agents ai and aj.\nSuppose a set of tasks T = {t1, t2, . . . , tn} arrives at such\nan agent social network. Each task t \u00e2\u02c6\u02c6 T is then defined by\na tuple u(t), rsc(t), loc(t) , where u(t) is the utility gained\nif task t is accomplished, and the resource function rsc :\nT \u00c3\u2014R \u00e2\u2020\u2019 N specifies the amount of resources required for the\naccomplishment of task t. Furthermore, a location function\nloc : T \u00e2\u2020\u2019 A defines the locations (i.e., agents) at which the\ntasks arrive in the social network. An agent a that is the\nlocation of a task t, i.e. loc(t) = a, is called the manager of\nthis task.\nEach task t \u00e2\u02c6\u02c6 T needs some specific resources from the\nagents in order to complete the task. The exact assignment\nof tasks to agents is defined by a task allocation.\nDefinition 2 (Task allocation). Given a set of tasks\nT = {t1, . . . , tn} and a set of agents A = {a1, . . . , am}\nin a social network SN, a task allocation is a mapping\n\u00cf\u2020 : T \u00c3\u2014 A \u00c3\u2014 R \u00e2\u2020\u2019 N. A valid task allocation in SN must\nsatisfy the following constrains:\n\u00e2\u20ac\u00a2 A task allocation must be correct. Each agent a \u00e2\u02c6\u02c6 A\ncannot use more than its available resources, i.e. for\neach r \u00e2\u02c6\u02c6 R,\nP\nt\u00e2\u02c6\u02c6T \u00cf\u2020(t, a, r) \u00e2\u2030\u00a4 rsc(a, r).\n\u00e2\u20ac\u00a2 A task allocation must be complete. For each task t \u00e2\u02c6\u02c6\nT , either all allocated agents\" resources are sufficient,\ni.e. for each r \u00e2\u02c6\u02c6 R,\nP\na\u00e2\u02c6\u02c6A \u00cf\u2020(t, a, r) \u00e2\u2030\u00a5 rsc(t, r), or t is\nnot allocated, i.e. \u00cf\u2020(t, \u00c2\u00b7, \u00c2\u00b7) = 0.\n\u00e2\u20ac\u00a2 A task allocation must obey the social relationships.\nEach task t \u00e2\u02c6\u02c6 T can only be allocated to agents that are\n(direct) neighbors of agent loc(t) in the social network\nSN. Each such agent that can contribute to a task is\ncalled a contractor.\nWe write T\u00cf\u2020 to represent the tasks that are fully allocated\nin \u00cf\u2020. The utility of \u00cf\u2020 is then the summation of the utilities of\neach task in T\u00cf\u2020, i.e., U\u00cf\u2020 =\nP\nt\u00e2\u02c6\u02c6T\u00cf\u2020\nu(t). Using this notation,\nwe define the efficient task allocation below.\nDefinition 3 (Efficient task allocation). We say\na task allocation \u00cf\u2020 is efficient if it is valid and U\u00cf\u2020 is \nmaximized, i.e., U\u00cf\u2020 = max(\nP\nt\u00e2\u02c6\u02c6T\u00cf\u2020\nu(t)).\nWe are now ready to define the task allocation problem\nin social network that we study in this paper.\nDefinition 4 (Social task allocation problem).\nGiven a set of agents A connected by a social network\nSN = (A, AE), and a finite set of tasks T , the social task\nallocation problem (or STAP for short) is the problem of\nfinding the efficient task allocation \u00cf\u2020, such that \u00cf\u2020 is valid\nand the social welfare U\u00cf\u2020 is maximized.\n3. COMPLEXITY RESULTS\nThe traditional task allocation problem, TAP (without\nthe condition of the social network SN), is NP-complete [18],\nand the complexity comes from the fact that we need to\nevaluate the exponential number of subsets of the task set.\nAlthough we may consider the TAP as a special case of the\nSTAP by assuming agents are fully connected, we cannot\ndirectly use the complexity results from the TAP, since we\nstudy the STAP in an arbitrary social network, which, as we\nargued in the introduction, should be partially connected.\nWe now show that the TAP with an arbitrary social \nnetwork is also NP-complete, even when the utility of each task\nis 1, and the quantity of all required and available resources\nis 1.\nTheorem 1. Given the social task allocation problem with\nan arbitrary social network, as defined in Definition 4, the\nproblem of deciding whether a task allocation \u00cf\u2020 with utility\nmore than k exists is NP-complete.\nProof. We first show that the problem is in NP. Given\nan instance of the problem and an integer k, we can verify in\npolynomial time whether an allocation \u00cf\u2020 is a valid allocation\nand whether the utility of \u00cf\u2020 is greater than k.\nWe now prove that the STAP is NP-hard by showing\nthat MAXIMUM INDEPENDENT SET \u00e2\u2030\u00a4P STAP. Given\nan undirected graph G = (V, E) and an integer k, we \nconstruct a network G = (V , E ) which has an efficient task\nallocation with k tasks of utility 1 allocated if and only if G\nhas an independent set (IS) of size k.\nav1\nav3\nae3\nrsc(ae1\n) = {e1}\nrsc(ae4\n) = {e4}\nav4\nae2\nav2\nae4\nae1\nrsc(ae2 ) =\n{e2}{e3}\nrsc(av3\n) =\n{v3}\nrsc(av4\n) =\n{v4}\nt1 = {v1, e1, e3} t2 = {v2, e1, e2}\nrsc(ae3 ) =\nrsc(av1\n) =\n{v1}\nrsc(av2\n) =\n{v2}\nt3 = {v3, e3, e4} t4 = {v4, e2, e4}\ne1\ne2\ne4\ne3\nv1 v2\nv4v3\nFigure 1: The MIS problem can be reduced to the\nSTAP. The left figure is an undirected graph G, which\nhas the optimal solution {v1, v4} or {v2, v3}; the right \nfigure is the constructed instance of the STAP, where the\noptimal allocation is {t1, t4} or {t2, t3}.\nAn instance of the following construction is shown in \nFigure 1. For each node v \u00e2\u02c6\u02c6 V and each edge e \u00e2\u02c6\u02c6 E in the graph\nG, we create a vertex agent av and an edge agent ae in G .\nThe Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 501\nWhen v was incident to e in G we correspondingly add an\nedge e in G between av and ae. We assign each agent in G\none resource, which is related to the node or the edge in the\ngraph G, i.e., for each v \u00e2\u02c6\u02c6 V , rsc(av) = {v} (here we write\nrsc(a) and rsc(t) to represent the set of resources available\nto/required by a and t), and for each e \u00e2\u02c6\u02c6 E, rsc(ae) = {e}.\nEach vertex agent avi in G has a task ti that requires a\nset of neighboring resources ti = {vi} \u00e2\u02c6\u00aa {e|e = (u, vi) \u00e2\u02c6\u02c6 E}.\nThere is no task on the edge agents in G . We define utility 1\nfor each task, and the quantity of all required and available\nresources to be 1.\nTaken an instance of the IS problem, suppose there is a\nsolution of size k, i.e., a subset N \u00e2\u0160\u2020 V such that no two\nvertices in N are joined by an edge in E and |N| = k.\nN specifies a set of vertex agents AN in the corresponding\ngraph G . Given two agents a1, a2 \u00e2\u02c6\u02c6 AN we now know that\nthere is no edge agent ae connected to both a1 and a2. Thus,\nfor each agent a \u00e2\u02c6\u02c6 AN , a assigns its task to the edge agents\nwhich are connected to a. All other vertex agents a /\u00e2\u02c6\u02c6 AN\nare not able to assign their tasks, since the required resources\nof the edge agents are already used by the agents a \u00e2\u02c6\u02c6 AN .\nThe set of tasks of the agents AN (|AN | = k) is thus the\nmaximum set of tasks that can be allocated. The utility of\nthis allocation is k.\nSimilarly, if there is a solution for the STAP with the\nutility value k, and the allocated task set is N, then for the\nIS problem, there exists a maximum independent set N of\nsize k in G. An example can be found in Figure 1.\nWe just proved that the STAP is NP-hard for an \narbitrary graph. In our proof, the complexity comes from the\nintroduction of a social network. One may expect that the\ncomplexity of this problem can be reduced for some networks\nwhere the number of neighbors of the agents is bounded by\na fixed constant. We now give a complexity result on this\nclass of networks as follows.\nTheorem 2. Let the number of neighbors of each agent\nin the social network SN be bounded by \u00ce\u201d for \u00ce\u201d \u00e2\u2030\u00a5 3. \nComputing the efficient task allocation given such a network is\nNP-complete. In addition, it is not approximable within \u00ce\u201d\u00ce\u00b5\nfor some \u00ce\u00b5 > 0.\nProof. It has been shown in [2] that the maximum \nindependent set problem in the case of the degree bounded by\n\u00ce\u201d for \u00ce\u201d \u00e2\u2030\u00a5 3 is NP-complete and is not approximable within\n\u00ce\u201d\u00ce\u00b5\nfor some \u00ce\u00b5 > 0. Using the similar reduction from the\nproof of Theorem 1, this result also holds for the STAP.\nSince our problem is as hard as MIS as shown in \nTheorem 1, it is not possible to give a worst case bound better\nthan \u00ce\u201d\u00ce\u00b5\nfor any polynomial time algorithm, unless P = NP.\n4. ALGORITHMS\nTo deal with the problem of allocating tasks in a social\nnetwork, we present a distributed algorithm. We introduce\nthis algorithm by describing the protocol for the agents. \nAfter that we give the optimal, centralized algorithm and an\nupper bound algorithm, which we use in Section 5 to \nbenchmark the quality of our distributed algorithm.\n4.1 Protocol for distributed task allocation\nWe can summarize the description of the task allocation\nproblem in social networks from Section 2 as follows. We\nAlgorithm 1 Greedy distributed allocation protocol\n(GDAP).\nEach manager a calculates the efficiency e(t) for each of their\ntasks t \u00e2\u02c6\u02c6 Ta, and then while Ta = \u00e2\u02c6\u2026:\n1. Each manager a selects the most efficient task t \u00e2\u02c6\u02c6 Ta\nsuch that for each task t \u00e2\u02c6\u02c6 Ta: e(t ) \u00e2\u2030\u00a4 e(t).\n2. Each manager a requests help for t from all its \nneighbors (of a) by informing these neighbors of the \nefficiency e(t) and the required resources for t.\n3. Contractors receive and store all requests, and then\noffer all relevant resources to the manager for the task\nwith the highest efficiency.\n4. The managers that have received sufficient offers \nallocate their tasks, and inform each contractor which\npart of the offer is accepted. When a task is \nallocated, or when a manager has received offers from all\nneighbors, but still cannot satisfy its task, the task is\nremoved from the task list Ta.\n5. Contractors update their used resources.\nhave a (social) network of agents. Each agent has a set of\nresources of different types at its disposal. We also have a\nset of tasks. Each task requires some resources, has a fixed\nbenefit, and is located at a certain agent. This agent is called\na manager. We only allow neighboring agents to help with a\ntask. These agents are called contractors. Agents can fulfill\nthe role of manager as well as contractor. The problem is\nto find out which tasks to execute, and which resources of\nwhich contractors to use for these tasks.\nThe idea of the protocol is as follows. All manager agents\na \u00e2\u02c6\u02c6 A try to find neighboring contractors to help them with\ntheir task(s) Ta = {ti \u00e2\u02c6\u02c6 T | loc(ti) = a}. They start with\noffering the task that is most efficient in terms of the ratio\nbetween benefit and required resources. Out of all tasks \noffered, contractors select the task with the highest efficiency,\nand send a bid to the related manager. A bid consists of all\nthe resources the agent is able to supply for this task. If \nsufficient resources have been offered, the manager selects the\nrequired resources and informs all contractors of its choice.\nThe efficiency of a task is defined as follows:\nDefinition 5. The efficiency e of a task t \u00e2\u02c6\u02c6 T is defined\nby the utility of this task divided by the sum of all required\nresources: e(t) = u(t)P\nr\u00e2\u02c6\u02c6R rsc(t,r)\n.\nA more detailed description of this protocol can be found\nin Algorithm 1. Here it is also defined how to determine\nwhen a task should not be offered anymore, because it is\nimpossible to fulfill locally. Obviously, a task is also not\noffered anymore when it has been allocated. This protocol\nis such that, when no two tasks have exactly the same \nefficiency, in every iteration at least one task is removed from\na task list.1\nFrom this the computation and communication\nproperty of the algorithm follows.\nProposition 1. For a STAP with n tasks and m agents,\nthe run time of the distributed algorithm is O(nm), and the\nnumber of communication messages is O(n2\nm).\n1\nEven when some tasks have the same efficiency, it is\nstraightforward to make this result work. For example, the\nimplementation can ensure that the contractors choose the\ntask with the lowest task-id.\n502 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)\nAlgorithm 2 Optimal social task allocation (OPT).\nRepeat the following for each combination of tasks:\n1. If the total reward for this combination is higher than\nany previous combination, test if this combination is\nfeasible as follows:\n2. Create a network flow problem for each resource type\nr \u00e2\u02c6\u02c6 R (separately) as follows:\n(a) Create a source s and a sink s .\n(b) For each agent a \u00e2\u02c6\u02c6 A create an agent node and\nan edge from s to this node with capacity equal\nto the amount of resources of type r agent a has.\n(c) For each task t \u00e2\u02c6\u02c6 T create a task node and an\nedge from this node to s with capacity equal to\nthe amount of resources of type r task T requires.\n(d) For each agent a connect the agent node to all\ntask nodes of neighboring tasks, i.e., t \u00e2\u02c6\u02c6 {t \u00e2\u02c6\u02c6 T |\n(a, loc(t)) \u00e2\u02c6\u02c6 AE}. Give this connection unlimited\ncapacity.\n3. Solve the maximum flow problem for the created flow\nnetworks. If the maximum flow in each network is\nequal to the total required resources of that type, the\ncurrent combination of tasks is feasible. In that case,\nthis is the current best combination of tasks.\nProof. In the worst case, in each iteration exactly one\ntask is removed from a task list, so there are n iterations.\nIn each iteration in the worst case (i.e., a fully connected\nnetwork), for each of the O(n) managers, O(m) messages\nare sent. Next the task with the highest efficiency can be\nselected by each contractor in O(n). Assigning an allocation\ncan be done in O(m). This leads to a total of O(n + m) \noperations for each iteration, and thus O(n2\n+ nm) operations\nin total. The number of messages sent is O(n(nm + nm +\nnm)) = O(n2\nm).\nWe establish the quality of this protocol experimentally\n(in Section 5). Preferably, we compare the results to the\noptimal solution.\n4.2 Optimal social task allocation\nThe optimal task allocation algorithm should deal with\nthe restrictions posed by the social network. For this \nNPcomplete problem we used an exponential brute-force \nalgorithm to consider relevant combinations of tasks to execute.\nFor each combination we use a maximum-flow algorithm to\ncheck whether the resources are sufficient for the selected\nsubset of tasks. The flow network describes which resources\ncan be used for which tasks, depending on the social \nnetwork. If the maximum flow is equal to the sum of all \nresources required by the subset of tasks, we know that a \nfeasible solution exists (see Algorithm 2). Clearly, we cannot\nexpect this optimal algorithm to be able to find solutions\nfor larger problem sizes. To establish the quality of our \nprotocol for large instances, we use the following method to\ndetermine an upper bound.\n4.3 Upper bound for social task allocation\nGiven a social task allocation problem, if the number of\nresource types for every task t \u00e2\u02c6\u02c6 T is bounded by 1, the\nAlgorithm 3 An upper bound for social task allocation\n(UB).\nCreate a network flow problem with costs as follows:\n1. Create a source s and a sink s .\n2. For each agent a \u00e2\u02c6\u02c6 A and each resource type ri \u00e2\u02c6\u02c6 R,\ncreate an agent-resource node ai, and an edge from\ns to this node with capacity equal to the amount of\nresources of type r agent a has available and with costs\n0.\n3. For each task t \u00e2\u02c6\u02c6 T and each resource type ri \u00e2\u02c6\u02c6 R, \ncreate a task-resource node ti, and an edge from this node\nto s with capacity equal to the amount of resources of\ntype r task t requires and costs \u00e2\u02c6\u2019e(t).\n4. For each resource type ri \u00e2\u02c6\u02c6 R and for each agent a\nconnect the agent-resource node ai to all task-resource\nnodes ti for neighboring tasks t \u00e2\u02c6\u02c6 {t \u00e2\u02c6\u02c6 T | (a, loc(t)) \u00e2\u02c6\u02c6\nAE or a = loc(t)}. Give this connection unlimited\ncapacity and zero costs.\n5. Create an edge directly from s to s with unlimited\ncapacity and zero costs.\nSolve the minimum cost flow network problem for this \nnetwork. The costs of the resulting network is an upper bound\nfor the social task allocation problem.\nproblem is polynomially solvable by transforming it to a flow\nnetwork problem. Our method for efficiently calculating an\nupper bound for STAP makes use of this special case by\nconverting any given STAP instance P into a new problem\nP where each task only has one resource type.\nMore specifically, for every task t \u00e2\u02c6\u02c6 T with utility u(t),\nwe do the following. Let m be the number of resource types\n{r1, . . . , rm} required by t. We then split t into a set of\nm tasks T = {t1, . . . , tm} where each task ti only has one\nunique resource type (of {r1, . . . , rm}) and each task has a\nfair share of the utility, i.e., the efficiency of t from \nDefinition 5 times the amount of this resource type rsc(ti, ri).\nAfter polynomially performing this conversion for every task\nin T , the original problem P becomes the special case P .\nNote that the set of valid allocations in P is only a subset of\nthe set of valid allocations in P , because it is now possible\nto partially allocate a task. From this it is easy to see that\nthe solution of P gives an upper bound of the solution of\nthe original problem P.\nTo compute the optimal solution for P , we transform it\nto a minimum cost flow problem. We model the cost in\nthe flow network by the negation of the new task\"s utility. A\npolynomial-time implementation of a scaling minimum cost\nflow algorithm [9] is used for the computation. The \nresulting minimum cost flow represents a maximum allocation of\nthe tasks for P . The detailed modeling is described in \nAlgorithm 3. In the next section, we use this upper bound to\nestimate the quality of the GDAP for large-scale instances.\n5. EXPERIMENTS\nWe implemented the greedy distributed allocation \nprotocol (GDAP), the optimal allocation algorithm (OPT), and\nthe upper bound algorithm (UB) in Java, and tested them\non a Linux PC. The purpose of these experiments is to study\nthe performance of the distributed algorithm in different\nproblem settings using different social networks. The \nperThe Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 503\n0.7\n0.8\n0.9\n1\n1.1\n1.2\n1.3\n1.4\n0.4 0.6 0.8 1 1.2 1.4 1.6\nRewardrelativetooptimal\nResource ratio\nsmall-world - upper bound\nrandom - upper bound\nscale-free - upper bound\nsmall-world - GDAP\nrandom - GDAP\nscale-free - GDAP\nFigure 2: The solution qualities of the GDAP and\nthe upper bound depend on the resource ratio.\n0\n5\n10\n15\n20\n25\n30\n0 2 4 6 8 10 12 14 16 18\nNumberofagents\nDegree\nsmall-world\nrandom\nscale-free\nFigure 3: The histogram of the degrees.\nformance measurements are the solution quality and \ncomputation time, where the solution quality (SQ) is computed\nas follows. When the number of tasks is small, we compare\nthe output of the distributed algorithm with the optimal \nsolution, i.e., SQ = GDAP\nOP T\n, but if it is not feasible to compute\nthe optimal solution, we use the value returned by the upper\nbound algorithm for evaluation, i.e., SQ = GDAP\nUB\n.\nTo see whether the latter is a good measure, we also \ncompare the quality of the upper bound to the optimal solution\nfor smaller problems. In the following, we describe the \nsetup of all experiments, and present the results.\n5.1 Experimental settings\nWe consider several experimental environments. In all \nenvironments the agents are connected by a social network. In\nthe experiments, three different networks are used to \nsimulate the social relationships among agents in potential \nrealworld problems.\nSmall-world networks are networks where most neighbors\nof an agent are also connected to each other. For the \nexperiments we use a method for generating random small-world\nnetworks proposed by Watts et al. [22], with a fixed rewiring\nprobability p = 0.05.\nScale-free networks have the property that a couple of\nnodes have many connections, and many nodes have only\na small number of connections. To generate these we use\nthe implementation in the JUNG library of the generator\nproposed by Barab\u00c2\u00b4asi and Albert [3].\nWe also generate random networks as follows. First we\nconnect each agent to another agent such that all agents are\nconnected. Next, we randomly add connections until the\ndesired average degree has been reached.\nWe now describe the different settings used in our \nexperiments with both small and large-scale problems.\nSetting 1. The number of agents is 40, and the number of\ntasks is 20. The number of different resource types is\nbounded by 5, and the average number of resources \nrequired by a task is 30. Consequently, the total number\nof resources required by the tasks is fixed. However,\nthe resources available to the agents are varied. We\ndefine the resource ratio to refer to the ratio between\nthe total number of available resources and the total\nnumber of required resources. Resources are allocated\nuniformly to the agents. The average degrees of the\nnetworks may also change. In this setting the task\nbenefits are distributed normally around the number\nof resources required.\nSetting 2. This setting is similar to Setting 1, but here we\nlet the benefits of the tasks vary dramatically-40% of\nthe tasks have around 10 times higher benefit than the\nother 60% of the tasks.\nSetting 3. This setting is for large-scale problems. The \nratio between the number of agents and the number of\ntasks is set to 5/3, and the number of agents varies\nfrom 100 to 2000. We also fix the resource ratio to 1.2\nand the average degree to 6. The number of different\nresource types is 20, and the average resource \nrequirement of a tasks is 100. The task benefits are again\nnormally distributed.\n5.2 Experimental results\nThe experiments are done with the three different settings\nin the three different networks mentioned before, where each\nrecorded data is the average over 20 random instances.\n5.2.1 Experiment 1\nExperimental setting 1 is used for this set of experiments.\nWe would like to see how the GDAP behaves in the \ndifferent networks when the number of resources available to the\nagents is changing. We also study the behavior of our upper\nbound algorithm. For this experiment we fix the average\nnumber of neighbors (degree) in each network type to six.\nIn Figure 2 we see how the quality of both the upper\nbound and the GDAP algorithm depends on the resource\nratio. Remarkably, for lower resource ratios our GDAP is\nmuch closer to the optimal allocation than the upper bound.\nWhen the resource ratio grows above 1.5, the graphs of the\nupper bound and the GDAP converge, meaning that both\nare really close to the optimal solution. This can be \nexplained by the fact that when plenty of resources are \navailable, all tasks can be allocated without any conflicts. \nHowever, when resources are very scarce, the upper bound is\nmuch too optimistic, because it is based on the allocation of\nsub-tasks per resource type, and does not reason about how\nmany of the tasks can actually be allocated completely. We\nalso notice from the graph that the solution quality of the\nGDAP on all three networks is quite high (over 0.8) when\nthe available resource is very limited (0.3). It drops below\n0.8 with the increased ratio and goes up again once there are\nplenty of resources available (resource ratio 0.9). Clearly, if\n504 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)\n0.7\n0.8\n0.9\n1\n1.1\n1.2\n1.3\n1.4\n2 4 6 8 10 12 14 16\nRewardrelativetooptimal\nDegree\nsmall-world - upper bound\nrandom - upper bound\nscale-free - upper bound\nsmall-world - GDAP\nrandom - GDAP\nscale-free - GDAP\nFigure 4: The quality of the GDAP and the upper\nbound depend on the network degree.\nresources are really scarce, only a few tasks can be \nsuccessfully allocated even by the optimal algorithm. Therefore,\nthe GDAP is able to give quite a good allocation.\nAlthough the differences are minor, it can also be seen\nthat the results for the small-world network are consistently\nslightly better than those of random networks, which in turn\noutperform scale-free networks. This can be understood by\nlooking at the distribution of the agents\" degree, as shown\nin Figure 3. In this experiment, in the small-world network\nalmost every manager has a degree of six. In random \nnetworks, the degree varies between one and about ten. \nHowever, in the scale-free network, most nodes have only three\nor four connections, and only a very few have up to twenty\nconnections. As we will see in the next experiment, having\nmore connections means getting better results.\nFor the next experiment we fix the resource ratio to 1.0\nand study the quality of both the upper bound and the\nGDAP algorithm related to the degree of the social \nnetwork. The result can be found in Figure 4. In this figure\nwe can see that a high average degree also leads to \nconvergence of the upper bound and the GDAP. Obviously, when\nmanagers have many connections, it becomes easier to \nallocate tasks. An exception is, similar to what we have seen in\nFigure 2, that the solution of the GDAP is also very good\nif the connections are extremely limited (degree 2), due to\nthe fact that the number of possibly allocated tasks is very\nsmall. Again we see that the upper bound is not that good\nfor problems where resources are hard to reach, i.e. in social\nnetworks with a low average degree.2\nSince the solution quality clearly depends on the resource\nratio as well as on the degree of the social network, we study\nthe effect of changing both, to see whether they influence\neach other. Figure 5 shows how the solution quality \ndepends on both the resource ratio and the network degree.\nThis graph confirms the results that the GDAP performs\nbetter for problems with higher degree and higher resource\nratio. However, it is now also more clear that it performs\nbetter for very low degree and resource availability. For this\nexperiment with 40 agents and 20 tasks, the worst \nperformance is met for instances with degree six and resource ratio\n0.6 to instances with degree twelve and resource ratio 0.3.\nBut even for those instances, the performance lies above 0.7.\n2\nThe consistent standard deviation of about 15% over the\n20 problem instances is not displayed as error-bars in these\nfirst graphs, because it would obfuscate the interesting \ncorrelations that can now be seen.\n4\n6\n8\n10\n12\n14\n16 0.4 0.6 0.8 1 1.2 1.4 1.6\n0.7\n0.75\n0.8\n0.85\n0.9\n0.95\n1\nRelative reward\nsmall-world\nAverage degree\nResource ratio\nRelative reward\nFigure 5: The quality of the GDAP depends on both\nthe resource ratio and the network degree.\n5.2.2 Experiment 2\nTo study the robustness of the GDAP against different\nproblem settings, we generate instances where the task \nbenefit distribution is different: 40% of the tasks gets a 10 times\nhigher benefit (as described in Setting 2). The effect of this\ndifferent distribution can be seen in Figure 6. These two\ngraphs show that the results for the skewed task benefit\ndistribution are slightly better on average, both when \nvarying the resource ratio, and when varying the average degree\nof the network. We argue that this can be explained by the\ngreedy nature of GDAP, which causes the tasks with high\nefficiency to be allocated first, and makes the algorithm \nperform better in this heterogeneous setting.\n5.2.3 Experiment 3\nThe purpose of this final experiment is to test whether the\nalgorithm can be scaled to large problems, like applications\nrunning on the internet. We therefore generate instances\nwhere the number of agents varies from 100 to 2000, and \nsimultaneously increase the number of tasks from 166 to 3333\n(Setting 3). Figure 7 shows the run time for these instances\non a Linux machine with an AMD Opteron 2.4 GHz \nprocessor. These graphs confirm the theoretical analysis from\nthe previous section, saying that both the upper bound and\nthe GDAP are polynomial. In fact, the graphs show that\nthe GDAP almost behaves linearly. Here we see that the\nlocality of the GDAP really helps in reducing the \ncomputation time. Also note that the GDAP requires even less\ncomputation time than the upper bound.\nThe quality of the GDAP for these large instances cannot\nbe compared to the optimal solution. Therefore, in Figure 8\nthe upper bound is used instead. This result shows that\nthe GDAP behaves stably and consistently well with the\nincreasing problem size. It also shows once more that the\nGDAP performs better in a small-world network.\n6. RELATED WORK\nTask allocation in multiagent systems has been \ninvestigated by many researchers in recent years with different \nassumptions and emphases. However, most of the research\nto date on task allocation does not consider social \nconnections among agents, and studies the problem in a centralized\nThe Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 505\n0.65\n0.7\n0.75\n0.8\n0.85\n0.9\n0.95\n1\n0.4 0.6 0.8 1 1.2 1.4 1.6\nRewardrelativetooptimal\nResource ratio\nskewed small-world\nskewed random\nskewed scale-free\nuniform small-world\nuniform random\nuniform scale-free\n0.7\n0.75\n0.8\n0.85\n0.9\n0.95\n1\n2 4 6 8 10 12 14 16\nRewardrelativetooptimal\nDegree\nskewed small-world\nskewed random\nskewed scale-free\nuniform small-world\nuniform random\nuniform scale-free\nFigure 6: The quality of the GDAP algorithm for a\nuniform and a skewed task benefit distribution \nrelated to the resource ratio (the first graph), and the\nnetwork degree (the second graph).\nsetting. For example, Kraus et al. [12] develop an auction\nprotocol that enables agents to form coalitions with time\nconstraints. It assumes each agent knows the capabilities\nof all others. The proposed protocol is centralized, where\none manager is responsible for allocating the tasks to all\ncoalitions. Manisterski at al. [14] discuss the possibilities of\nachieving efficient allocations in both cooperative and \nnoncooperative settings. They propose a centralized algorithm\nto find the optimal solution. In contrast to this work, we\nintroduce also an efficient completely distributed protocol\nthat takes the social network into account.\nTask allocation has also been studied in distributed \nsettings by for example Shehory and Kraus [18] and by \nLerman and Shehory [13]. They propose distributed algorithms\nwith low communication complexity for forming coalitions\nin large-scale multiagent systems. However, they do not\nassume the existence of any agent network. The work of\nSander et al. [16] introduces computational geometry-based\nalgorithms for distributed task allocation in geographical \ndomains. Agents are then allowed to move and actively search\nfor tasks, and the capability of agents to perform tasks is \nhomogeneous. In order to apply their approach, agents need\nto have some knowledge about the geographical positions\nof tasks and some other agents. Other work [17] proposes\na location mechanism for open multiagent systems to \nallocate tasks to unknown agents. In this approach each agent\ncaches a list of agents they know. The analysis of the \ncommunication complexity of this method is based on lattice-like\ngraphs, while we investigate how to efficiently solve task \nallocation in a social network, whose topology can be arbitrary.\nNetworks have been employed in the context of task \nallocation in some other works as well, for example to limit the\n0\n1000\n2000\n3000\n4000\n5000\n6000\n7000\n0 200 400 600 800 1000 1200 1400 1600 1800 2000\nTime(ms)\nAgents\nupper bound - small-world\nupper bound - random\nupper bound - scale-free\nGDAP - small-world\nGDAP - random\nGDAP - scale-free\nFigure 7: The run time of the GDAP algorithm.\n0.75\n0.8\n0.85\n0.9\n0.95\n1\n0 200 400 600 800 1000 1200 1400 1600 1800 2000\nRewardrelativetoupperbound\nAgents\nsmall-world\nrandom\nscale-free\nFigure 8: The quality of the GDAP algorithm \ncompared to the upper bound.\ninteractions between agents and mediators [1]. Mediators in\nthis context are agents who receive the task and have \nconnections to other agents. They break up the task into subtasks,\nand negotiate with other agents to obtain commitments to\nexecute these subtasks. Their focus is on modeling the \ndecision process of just a single mediator. Another approach is\nto partition the network into cliques of nodes, representing\ncoalitions which the agents involved may use as a \ncoordination mechanism [20]. The focus of that work is distributed\ncoalition formation among agents, but in our approach, we\ndo not need agents to form groups before allocating tasks.\nEaswaran and Pitt [6] study \u00e2\u20ac\u02dccomplex tasks\" that require\n\u00e2\u20ac\u02dcservices\" for their accomplishment. The problem concerns\nthe allocation of subtasks to service providers in a supply\nchain. Another study of task allocation in supply chains\nis [21], where it is argued that the defining characteristic\nof Supply Chain Formation is hierarchical subtask \ndecomposition (HSD). HSD is implemented using task dependency\nnetworks (TDN), with agents and goods as nodes, and I/O\nrelations between them as edges. Here, the network is given,\nand the problem is to select a subgraph, for which the \nauthors propose a market-based algorithm, in particular, a \nseries of auctions. Compared to these works, our approach is\nmore general in the sense that we are able to model different\ntypes of connections or constraints among agents for \ndifferent problem domains in addition to supply chain formation.\nFinally, social networks have been used in the context of\nteam formation. Previous work has shown how to learn\nwhich relations are more beneficial in the long run [8], and\nadapt the social network accordingly. We believe these \nresults can be transferred to the domain of task allocation as\nwell, leaving this as a topic for further study.\n506 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)\n7. CONCLUSIONS\nIn this paper we studied the task allocation problem in a\nsocial network (STAP), which can be seen as a new, more\ngeneral, variant of the TAP. We believe it has a great amount\nof potential for realistic problems. We provided complexity\nresults on computing the efficient solution for the STAP, as\nwell as a bound on possible approximation algorithms. Next,\nwe presented a distributed protocol, related to the \ncontractnet protocol. We also introduced an exponential algorithm\nto compute the optimal solution, as well as a fast \nupperbound algorithm. Finally, we used the optimal solution and\nthe upper-bound (for larger instances) to conduct an \nextensive set of experiments to assess the solution quality and\nthe computational efficiency of the proposed distributed \nalgorithm in different types of networks, namely, small-world\nnetworks, random networks, and scale-free networks.\nThe results presented in this paper show that the \ndistributed algorithm performs well in small-world, scale-free,\nand random networks, and for many different settings. Also\nother experiments were done (e.g. on grid networks) and\nthese results held up over a wider range of scenarios. \nFurthermore, we showed that it scales well to large networks,\nboth in terms of quality and of required computation time.\nThe results also suggest that small-world networks are slightly\nbetter suited for local task allocation, because there are no\nnodes with very few neighbors.\nThere are many interesting extensions to our current work.\nIn this paper, we focus on the computational aspect in the\ndesign of the distributed algorithm. In our future work, we\nwould also like to address some of the related issues in game\ntheory, such as strategic agents, and show desirable \nproperties of a distributed protocol in such a context.\nIn the current algorithm we assume that agents can only\ncontact their neighbors to request resources, which may \nexplain why our algorithm performs not as good in the \nscalefree networks as in the small-world networks. Our future\nwork may allow agents to reallocate (sub)tasks. We are \ninterested in seeing how such interactions will affect the \nperformance of task allocation in different social networks.\nA third interesting topic for further work is the addition\nof reputation information among the agents. This may help\nto model changing business relations and incentivize agents\nto follow the protocol.\nFinally, it would be interesting to study real-life instances\nof the social task allocation problem, and see how they \nrelate to the randomly generated networks of different types\nstudied in this paper.\nAcknowledgments. This work is supported by the \nTechnology Foundation STW, applied science division of NWO,\nand the Ministry of Economic Affairs.\n8. REFERENCES\n[1] S. Abdallah and V. Lesser. Modeling Task Allocation\nUsing a Decision Theoretic Model. In Proc. AAMAS,\npages 719-726. ACM, 2005.\n[2] N. Alon, U. Feige, A. Wigderson, and D. Zuckerman.\nDerandomized Graph Products. Computational\nComplexity, 5(1):60-75, 1995.\n[3] A.-L. Barab\u00c2\u00b4asi and R. Albert. Emergence of scaling in\nrandom networks. Science, 286(5439):509-512, 1999.\n[4] R. H. Coase. The Nature of the Firm. Economica NS,\n4(16):386-405, 1937.\n[5] R. H. Coase. My Evolution as an Economist. In\nW. Breit and R. W. Spencer, editors, Lives of the\nLaureates, pages 227-249. MIT Press, 1995.\n[6] A. M. Easwaran and J. Pitt. Supply Chain Formation\nin Open, Market-Based Multi-Agent Systems.\nInternational J. of Computational Intelligence and\nApplications, 2(3):349-363, 2002.\n[7] I. Foster, N. R. Jennings, and C. Kesselman. Brain\nMeets Brawn: Why Grid and Agents Need Each\nOther. In Proc. AAMAS, pages 8-15, Washington,\nDC, USA, 2004. IEEE Computer Society.\n[8] M. E. Gaston and M. desJardins. Agent-organized\nnetworks for dynamic team formation. In Proc.\nAAMAS, pages 230-237, New York, NY, USA, 2005.\nACM Press.\n[9] A. Goldberg. An Efficient Implementation of a Scaling\nMinimum-Cost Flow Algorithm. J. of Algorithms,\n22:1-29, 1997.\n[10] R. Gulati. Does Familiarity Breed Trust? The\nImplications of Repeated Ties for Contractual Choice\nin Alliances. Academy of Management Journal,\n38(1):85-112, 1995.\n[11] T. Klos and B. Nooteboom. Agent-based\nComputational Transaction Cost Economics.\nEconomic Dynamics and Control, 25(3-4):503-526, 01.\n[12] S. Kraus, O. Shehory, and G. Taase. Coalition\nformation with uncertain heterogeneous information.\nIn Proc. AAMAS, pages 1-8. ACM, 2003.\n[13] K. Lerman and O. Shehory. Coalition formation for\nlarge-scale electronic markets. In Proc. ICMAS, pages\n167-174. IEEE Computer Society, 2000.\n[14] E. Manisterski, E. David, S. Kraus, and N. Jennings.\nForming Efficient Agent Groups for Completing\nComplex Tasks. In Proc. AAMAS, pages 257-264.\nACM, 2006.\n[15] J. Patel et al. Agent-Based Virtual Organizations for\nthe Grid. Multi-Agent and Grid Systems,\n1(4):237-249, 2005.\n[16] P. V. Sander, D. Peleshchuk, and B. J. Grosz. A\nscalable, distributed algorithm for efficient task\nallocation. In Proc. AAMAS, pages 1191-1198, New\nYork, NY, USA, 2002. ACM Press.\n[17] O. Shehory. A scalable agent location mechanism. In\nProc. ATAL, volume 1757 of LNCS, pages 162-172.\nSpringer, 2000.\n[18] O. Shehory and S. Kraus. Methods for Task\nAllocation via Agent Coalition Formation. Artificial\nIntelligence, 101(1-2):165-200, 1998.\n[19] R. M. Sreenath and M. P. Singh. Agent-based service\nselection. Web Semantics, 1(3):261-279, 2004.\n[20] P. T. To\u00cb\u2021si\u00c2\u00b4c and G. A. Agha. Maximal Clique Based\nDistributed Coalition Formation for Task Allocation\nin Large-Scale Multi-Agent Systems. In Proc. MMAS,\nvolume 3446 of LNAI, pages 104-120. Springer, 2005.\n[21] W. E. Walsh and M. P. Wellman. Modeling Supply\nChain Formation in Multiagent Systems. In Proc.\nAMEC II, volume 1788 of LNAI, pages 94-101.\nSpringer, 2000.\n[22] D. J. Watts and S. H. Strogatz. Collective dynamics of\n\u00e2\u20ac\u02dcsmall world\" networks. Nature, 393:440-442, 1998.\nThe Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 507\n": ["social network", "social relationship", "task allocation", "utility", "allocation", "algorithm", "communication message", "behavior", "multiagent system", "strategic agent", "interaction", "agent", "resource", "computational complexity", ""]}