{"Edge Indexing in a Grid for Highly Dynamic Virtual\nEnvironments\u00e2\u02c6\u2014\nBeomjoo Seo\nbseo@usc.edu\nRoger Zimmermann\nrzimmerm@imsc.usc.edu\nComputer Science Department\nUniversity of Southern California\nLos Angeles, CA 90089\nABSTRACT\nNewly emerging game-based application systems such as Second\nLife1\nprovide 3D virtual environments where multiple users \ninteract with each other in real-time. They are filled with autonomous,\nmutable virtual content which is continuously augmented by the\nusers. To make the systems highly scalable and dynamically \nextensible, they are usually built on a client-server based grid subspace\ndivision where the virtual worlds are partitioned into manageable\nsub-worlds. In each sub-world, the user continuously receives\nrelevant geometry updates of moving objects from remotely \nconnected servers and renders them according to her viewpoint, rather\nthan retrieving them from a local storage medium.\nIn such systems, the determination of the set of objects that are\nvisible from a user\"s viewpoint is one of the primary factors that\naffect server throughput and scalability. Specifically, performing\nreal-time visibility tests in extremely dynamic virtual environments\nis a very challenging task as millions of objects and sub-millions of\nactive users are moving and interacting. We recognize that the \ndescribed challenges are closely related to a spatial database problem,\nand hence we map the moving geometry objects in the virtual space\nto a set of multi-dimensional objects in a spatial database while\nmodeling each avatar both as a spatial object and a moving query.\nUnfortunately, existing spatial indexing methods are unsuitable for\nthis kind of new environments.\nThe main goal of this paper is to present an efficient spatial \nindex structure that minimizes unexpected object popping and \nsupports highly scalable real-time visibility determination. We then\nuncover many useful properties of this structure and compare the\nindex structure with various spatial indexing methods in terms of\nquery quality, system throughput, and resource utilization. We \nexpect our approach to lay the groundwork for next-generation \nvirtual frameworks that may merge into existing web-based services\nin the near future.\nCategories and Subject Descriptors: C.2.4 [Computer - \nCommunication Networks]: Distributed Systems - Client/server, \nDistributed applications, Distributed databases; I.3.7 [Computer \nGraphics]: Three-Dimensional Graphics and Realism - Virtual Reality\nGeneral Terms: Algorithms, Design, Performance\n1. INTRODUCTION\nRecently, Massively Multiplayer Online Games (MMOGs) have\nbeen studied as a framework for next-generation virtual \nenvironments. Many MMOG applications, however, still limit themselves\nto a traditional design approach where their 3D scene complexity\nis carefully controlled in advance to meet real-time rendering \nconstraints at the client console side.\nTo enable a virtual landscape in next-generation environments\nthat is seamless, endless, and limitless, Marshall et al. [1] identified\nfour new requirements2\n: dynamic extensibility (a system allows\nthe addition or the change of components at run time); \nscalability (although the number of concurrent users increases, the \nsystem continues to function effectively); interactibility; and \ninteroperability. In this paper, we mainly focus on the first two \nrequirements.\nDynamic extensibility allows regular game-users to deploy their\nown created content. This is a powerful concept, but unfortunately,\nuser-created content tends to create imbalances among the \nexisting scene complexity, causing system-wide performance problems.\nFull support for dynamic extensibility will, thus, continue to be one\nof the biggest challenges for game developers.\nAnother important requirement is scalability. Although MMOG\ndevelopers proclaim that their systems can support hundreds of\nthousands of concurrent users, it usually does not mean that all\nthe users can interact with each other in the same world. By \ncarefully partitioning the world into multiple sub-worlds or replicating\nworlds at geographically dispersed locations, massive numbers of\nconcurrent users can be supported. Typically, the maximum \nnumber of users in the same world managed by a single server or a\nserver-cluster is limited to several thousands, assuming a rather\nstationary world [2, 3].\nSecond Life [4] is the first successfully deployed MMOG \nsystem that meets both requirements. To mitigate the dynamics of the\ngame world, where a large number of autonomous objects are \ncontinuously moving, it partitions the space in a grid-like manner and\n2\nOriginally, these requirements were specified for their dedicated\nplatform. But we acknowledge that these requirements are also\nvalid for new virtual environments.\n402\nAvatar\nObject PoppingAutonomous Entities\n(a) At time t (b) At time t+\u00ce\u201d\nFigure 1: Object popping occurred as a user moves forward\n(screenshots from Second Life) where \u00ce\u201d = 2 seconds.\nemploys a client/server based 3D object streaming model [5]. In\nthis model, a server continuously transmits both update events and\ngeometry data to every connected user. As a result, this \nextensible gaming environment has accelerated the deployment of \nusercreated content and provides users with unlimited freedom to \npursue a navigational experience in its space.\nOne of the main operations in MMOG applications that stream\n3D objects is to accurately calculate all objects that are visible to\na user. The traditional visibility determination approach, however,\nhas an object popping problem. For example, a house outside a\nuser\"s visible range is not drawn at time t, illustrated in Figure 1(a).\nAs the user moves forward, the house will suddenly appear at time\n(t + \u00ce\u201d) as shown in Figure 1(b). If \u00ce\u201d is small, or the house is\nlarge enough to collide with the user, it will disrupt the user\"s \nnavigational experience.\nThe visibility calculation for each user not only needs to be \naccurate, but also fast. This challenge is illustrated by the fact that the\nmaximum number of concurrent users per server of Second Life is\nstill an order of magnitude smaller than for stationary worlds.\nTo address these challenges, we propose a method that identifies\nthe most relevant visible objects from a given geometry database\n(view model) and then put forth a fast indexing method that \ncomputes the visible objects for each user (spatial indexing). Our two\nnovel methods represent the main contributions of this work.\nThe organization of this paper is as follows. Section 2 presents\nrelated work. Section 3 describes our new view method. In \nSection 4, we present assumptions on our target application and \nintroduce a new spatial indexing method designed to support real-time\nvisibility computations. We also discuss its optimization issues.\nSection 5 reports on the quantitative analysis and Section 6 presents\npreliminary results of our simulation based experiments. Finally,\nwe conclude and address future research directions in Section 7.\n2. RELATED WORK\nVisibility determination has been widely explored in the field of\n3D graphics. Various local rendering algorithms have been \nproposed to eliminate unnecessary objects before rendering or at any\nstage in the rendering pipeline. View-frustum culling, back-face\nculling, and occlusion culling are some of the well-known \nvisibility culling techniques [6]. However, these algorithms assume that\nall the candidate visible objects have been stored locally.\nIf the target objects are stored on remote servers, the clients \nreceive the geometry items that are necessary for rendering from the\nserver databases. Teller et al. described a geometry data scheduling\nalgorithm that maximizes the quality of the frame rate over time in\nremote walkthroughs of complex 3D scenes from a user\"s \nnavigational path [5]. Funkhouser et al. showed that multi-resolutional\nrepresentation, such as Levels Of Detail (LOD), can be used to\nimprove rendering frame rates and memory utilization during \ninteractive visualization [7]. However, these online optimization \nalgorithms fail to address performance issue at the server in highly\ncrowded environments. On the other hand, our visibility \ncomputation model, a representative of this category, is based on different\nassumptions on the data representation of virtual entities.\nIn the graphics area, there has been little work on supporting\nreal-time visibility computations for a massive number of moving\nobjects and users. Here we recognize that such graphics related\nissues have a very close similarity to spatial database problems.\nRecently, a number of publications have addressed the \nscalability issue on how to support massive numbers of objects and queries\nin highly dynamic environments. To support frequent updates, two\npartitioning policies have been studied in depth: (1) R-tree based\nspatial indexing, and (2) grid-based spatial indexing. The R-tree\nis a well-known spatial index structure that allows overlapping \nbetween the regions in different branches which are represented by\nMinimum Bounding Rectangles (MBR). The grid-based \npartitioning model is a special case of fixed partitioning. Recently, it has\nbeen re-discovered since it can be efficient in highly dynamic \nenvironments.\nMany studies have reported that the R-tree and its variants (R+\n\ntree, R\u00e2\u02c6\u2014\n-tree) suffer from unacceptable performance degradation in\na highly dynamic environment, primarily due to the computational\ncomplexity of the split algorithm [8, 9, 10, 11, 12]. A bottom-up\nupdate strategy proposed for R-trees [9] optimizes update \noperations of the index while maintaining a top down query processing\nmechanism. Instead of traversing a tree from the root node for \nfrequent update requests (top-down approach), it directly accesses the\nleaf node of the object to be updated via an object hash table.\nQ-Index [13, 11] is one of the earlier work that re-discovers\nthe usefulness of grid-based space partitioning for emerging \nmoving object environments. In contrast to traditional spatial indexing\nmethods that construct an index on the moving objects, it builds an\nindex on the continuous range queries, assuming that the queries\nmove infrequently while the objects move freely. The basic idea\nof the Q+Rtree [14] is to separate indexing structures for \nquasistationary objects and moving objects: fast-moving objects are \nindexed in a Quadtree and quasi-stationary objects are stored in an\nR\u00e2\u02c6\u2014\n-tree. SINA [10] was proposed to provide efficient query \nevaluations for any combination of stationary/moving objects and \nstationary/moving queries. Specifically, this approach only detects\nnewly discovered (positive) or no longer relevant (negative) object\nupdates efficiently. Unlike other spatial indexing methods that \nfocus on reducing the query evaluation cost, Hu et al. [12] proposed\na general framework that minimizes the communication cost for\nlocation updates by maintaining a rectangular area called a safe \nregion around moving objects. As long as any object resides in this\nregion, all the query results are guaranteed to be valid in the \nsystem. If objects move out of their region, location update requests\nshould be delivered to the database server and the affected queries\nare re-evaluated on the fly. Our indexing method is very similar\nto the above approaches. The major difference is that we are more\nconcentrating on real-time visibility determination while others \nassume loose timing constraints.\n3. OBJECT-INITIATED VIEW MODEL\nIn this section we illustrate how the object popping problem can be\nassociated with a typical view decision model. We then propose our\nown model, and finally we discuss its strengths and limitations. To\nbegin with, we define the terminologies commonly used throughout\nthis paper.\nEntities in a virtual space can be categorized into three types\n403\nbased on their role - autonomous entities, spectator entities, and\navatars. The term autonomous entity refers to an ordinary moving\nor stationary geometric object that can be visible to other entities.\nThe spectator entity corresponds to a player\"s viewpoint, but is \ninvisible to other entities. It has no shape and is represented only\nby a point location. It is designed to allow a game participant to\nsee from a third-person viewpoint. It functions similar to a \ncamera control in the 3D graphics field. It also has a higher degree of\nmobility than other entities. The avatar represents a normal game\nuser who can freely navigate in the space and interact with other\nentities. It possesses both features: its own viewpoint and \nvisibility. For the remainder we use the term object entity to refer to an\nautonomous entity or an avatar while we use user entity to denote\nan avatar or a spectator entity.\nThe visible range of an entity refers to the spatial extent within\nwhich any other entity can recognize its existence. It is based on\nthe assumptions that there always exists an optimal visible distance\nbetween a user and an object at any given time and every user \npossesses equal visibility. Thus, the user and the object, only when\ntheir current distance is smaller than or equal to the optimal, can\nsee each other. To specify the visible range, much literature in the\ngraphics area [5, 6] uses a circular Area Of Interest (AOI) whose\ncenter is the location of an entity. Its omnidirectional nature \nallows rapid directional changes without any display disruptions at\nthe periphery of the viewable area. However, we employ a \nsquareshaped AOI at the expense of accuracy because the square-shaped\nspatial extension is very simple and efficient to be indexed in a grid\npartitioned world.\nThe traditional view model, which we call user-initiated view\nmodel, assumes that a user entity has an AOI while an object entity\ndoes not. As the user navigates, she continuously searches for all\nthe entities within her AOI. Due to its simple design and its low \nindexing overhead, many Location Based Services (LBSs) and game\napplications use this model.\nHowever, the user-initiated model has a serious object popping\nproblem during navigation. Recall, as shown in Figure 1, that the\nhouse that will have appeared at time t + \u00ce\u201d does not appear at\ntime t because the user cannot recognize objects that are outside of\nher AOI at time t. In fact, it turned out that the side length of her\nAOI was smaller than the optimal distance between the user and the\nhouse at the time t. Therefore, there is no other way but to increase\nthe visible range of the user in this model to make such an \nexperience unlikely. A large AOI, however, may lead to a significant\nsystem degradation.\nTo overcome the object popping problem, we propose a new\nview model which we call object-initiated view model. All object\nentities have their own AOI centered at their current location while\nall spectator entities have no AOI. Every user entity recognizes the\nobjects whose AOIs cover its point location.\nThe main strengths of the new model are that (1) it has no object\npopping problem as long as the underlying system can manage the\noptimal visible range of all object entities correctly and that (2) the\ncontent creators can produce an enriched expressiveness of various\nbehavioral and temporal changes. A huge object may have a \nfarther visible range than a small one; an object has a broader visible\nrange during day-time than at night; even during the night the \nvisible range of an object that owns a light source will have a much\nwider visible area than a non-illuminated object; if an object is \nlocated inside a building, its visible range would be constrained by\nthe surrounding structure.\nOne of the potential arguments against the object-initiated view\nis that indexing of the spatial extension of an object is too complex\nto be practical, compared with the user-initiated view. We agree\nE2\nE1\nA\nS\nClient S\nClient A\nSub-world\nServer\nFigure 2: Target system in a 4 \u00c3\u2014 4 grid partition.\nthat existing spatial indexing methods are inefficient in \nsupporting our view model. To refute this argument, we propose a novel\nspatial indexing solution detailed in Section 4.4. Our spatial \nindexing solution offers a very promising performance even with a large\nnumber of mobile entities and visibility calculations in real-time.\nFor the rest of the paper our design scope is limited to a 2D space,\nalthough our application is targeted for 3D environments3\n.\nNote that our view model is not intended to rival a sophisticated\nvisibility decision algorithm such as visibility culling [6], but to \nefficiently filter out unnecessary entities that do not contribute to the\nfinal image. In Section 6.1 we evaluate both models through \nquantitatively measures such as the degree of expressiveness and the\nquality of the two view models and we discuss simulation results.\n4. DESIGN OF EDGE INDEXING\nIn Section 4.1 we introduce our target application model. Next,\nSection 4.2 presents an abstraction of our node and edge structures\nwhose detailed indexing and cell evaluation methods are explained\nlater in Sections 4.3 and 4.4. Several optimization issues for edge\nindexing follow in Section 4.5.\n4.1 Target Application\nOur target application assumes both 3D object streaming and\nsub-world hosting. The sub-world hosting is a collaborative \nvirtual environment where every server hosts one sub-world, thus\nconstructing a single world. Second Life is the classic example\nof such an approach.\nA virtual space is partitioned into equal-sized sub-worlds. The\nsample sub-world separated with bold-dashed lines in Figure 2\ncontains four virtual entities: two autonomous entities (E1, E2);\none spectator entity S; and one avatar A. As mentioned in \nSection 3, all object entities (E1, E2, A) have their own square-shaped\nAOI. Two user entities (S, A) are associated with individual client\nmachines, (client S and client A in the figure). The spatial \ncondition that the point location of S resides inside the AOI of E2 can\nbe symbolized as S.P \u00e2\u02c6\u02c6 E2.R.\nEvery sub-world is managed by its dedicated server machine.\nEach server indexes all the entities, delivers any new events (i.e.,\na new user enters into the sub-world or an object moves from one\nplace to another) to clients, and resolves any inconsistencies among\nthe entities. For efficient management of moving entities, a server\nfurther divides its sub-world into smaller partitions, called grid\ncells. Figure 2 shows the 4 \u00c3\u2014 4 grid enclosed by the dashed lines.\nInstead of indexing the object entities with a user entity structure,\nour system indexes their visible regions on the grid cells. Retrieval\nof the indexed objects for a given user includes the search and \nde3\nA better indexing method for a 3D space is work in progress.\n404\nTokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S)\n(a) node indexing (b) edge indexing\n(c) edge indexing with row-wise cell\nevaluation\nFigure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2. There are\nthree object entities, {E1, E2, A}, and two user entities, {S, A} in the world.\nlivery of the indices stored on the cell it is located in. This retrieval\nprocess is interchangeably called a user (or query) evaluation.\nOur application only considers the efficient indexing of virtual\nentities and the search for the most relevant entities - that is, how\nmany entities per sub-world are indexed and how quickly index\nupdates are recognized and retrieved. Efficient delivery of retrieved\nreal geometry data is out of the scope of this paper.\n4.2 Abstraction\nWe define a token as an abstraction of a virtual entity that \nsatisfies a specific spatial relationship with a given cell. In our \napplication, we use three types of tokens:\nInclusion Token (IT) indicates that its entity overlaps with or is\ncovered by the given cell.\nAppearance Token (AT) denotes that its entity is an IT for the\ngiven cell, but not for the previously adjacent cell.\nDisappearance Token (DT) is the opposite of AT, meaning that\nwhile its entity does not satisfy the IT relationship with the\ngiven cell, it does so with the previously adjacent cell.\nWe also define two data structures for storing and retrieving the\ntokens: a node and an edge. A node is a data structure that stores\nITs of a cell. Thus, the node for cell i is defined as a set of IT\nentities and formally expressed as Ni = {o|o.R\u00e2\u02c6\u00a9i.R = \u00e2\u02c6\u2026}, where\nR is either an AOI or a cell region. An edge is another data structure\nfor two adjacent cells that stores their ATs or DTs. If the edge\nonly stores the AT entities, it is termed an Appearance Edge (AE);\notherwise, if it stores DTs, it is termed a Disappearance Edge (DE).\nThe AE for two adjacent cells i and j is defined as a set of ATs and\nexpressed as\nE+(i, j) = Nj \u00e2\u02c6\u2019 (Ni \u00e2\u02c6\u00a9 Nj ) (1)\nwhere Ni and Nj are the node structures for the cells i and j. The\nDE for two adjacent cells i, j is defined as a set of DTs, satisfying:\nE\u00e2\u02c6\u2019(i, j) = Ni \u00e2\u02c6\u2019 (Ni \u00e2\u02c6\u00a9 Nj ) (2)\nIn a 2D map, depending on the adjacency relationship between\ntwo neighboring cells, edges are further classified as either \nrowwise, if two neighbors are adjacent horizontally (Er\n), or \ncolumnwise, if they are adjacent vertically (Ec\n). Consequently, edges are\nof four different types, according to their token type and adjacency:\nEr\n+(i, j), Er\n\u00e2\u02c6\u2019(i, j), Ec\n+(i, j), and Ec\n\u00e2\u02c6\u2019(i, j).\n4.3 Node Indexing\nGrid partitioning is a popular space subdivision method that has\nrecently gained popularity for indexing moving entities in highly\ndynamic virtual environments [12, 8, 13, 10]. To highlight the \ndifference to our newly proposed method, we term all existing grid\npartitioning-based indexing methods node indexing. Node \nindexing partitions the space into equi-sized subspaces (grid cells), \nindexes entities on each cell, and searches for entities that satisfy a\nspatial condition with a given query.\nIn many LBS applications, node indexing maintains a node \nstructure per cell and stores an index of entities whose spatial extent is\na point location. For a given range query, a search is performed\nfrom the node structures of the cells whose region intersects with\nthe spatial extent of the range query. Due to the use of a simple\npoint geometry for entities, this allows for lightweight index \nupdates. Much of the existing work falls into this category.\nHowever, if the spatial extent of an entity is a complex geometry\nsuch as rectangle, node indexing will suffer from significant system\ndegradation due to expensive update overhead. For example, a \nsingle movement of an entity whose spatial extent overlaps with 100\ngrid cells requires 100 token deletions and 100 token insertions, in\nthe worst case. One of the popular node indexing methods, Query\nIndexing, has been reported to have such performance degradation\nduring the update of rectangle-shaped range queries [13].\nFor the sample space shown in Figure 2, the concept of node\nindexing is illustrated in Figure 3(a). Every cell stores IT entities\nthat intersect with its region. Query processing for the spectator\nS means to search the node structure whose cell region intersects\nwith S. In Figure 3(a), E2 is indexed on the same cell, thus being\ndelivered to the client S after the query evaluation.\n4.4 Edge Indexing\nOur new indexing method, edge indexing, is designed to \nprovide an efficient indexing method for the specific spatial extension\n(square) of the entities in a grid. Its features are (1) an edge \nstructure and (2) periodic entity update and cell evaluation.\n4.4.1 Idea\nEdge Structure\nThe main characteristic of our approach is that it maintains edge\nstructures instead of using node structures. With this approach,\nredundant ITs between two adjacent cells (Ni \u00e2\u02c6\u00a9Nj ) are eliminated.\nIn a 2D M \u00c3\u2014 M grid map, each cell i is surrounded by four\nneighboring cells (i\u00e2\u02c6\u2019 1), (i+ 1), (i\u00e2\u02c6\u2019 M), (i+ M) (except for the\n405\noutermost cells) and eight different edge structures. If the first two\nneighbor cells are horizontally adjacent to i and the last two cells\n(i\u00e2\u02c6\u2019M), (i+M) are vertically nearby, the eight edge structures are\nEc\n+(i\u00e2\u02c6\u2019M, i), Ec\n\u00e2\u02c6\u2019(i\u00e2\u02c6\u2019M, i), Er\n+(i\u00e2\u02c6\u20191, i), Er\n\u00e2\u02c6\u2019(i\u00e2\u02c6\u20191, i), Er\n+(i, i+\n1), Er\n\u00e2\u02c6\u2019(i, i + 1), Ec\n+(i, i + M), and Ec\n\u00e2\u02c6\u2019(i, i + M).\nFigure 3(b) illustrates how edge structures are constructed from\nnode structures, using Equations 1 and 2. Inversely, the cell \nevaluation process with edge indexing derives node structures from the\nedge structures. If any node structure and all the edge structures are\nknown a priori, we can derive all the node structures as defined by\nLemma 1. The proof of Lemma 1 is trivial as it is easily induced\nfrom Equations 1 and 2.\nLemma 1. Nj , a set of ITs of a given cell j can be derived\nfrom a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) \u00e2\u02c6\u2019\nE\u00e2\u02c6\u2019(i, j):\nNj = Ni + E+(i, j) \u00e2\u02c6\u2019 E\u00e2\u02c6\u2019(i, j)\nRow-wise and column-wise edge structures, however, capture\nsome redundant information. Thus, na\u00c2\u00a8\u00c4\u00b1ve edge indexing stores\nmore tokens than node indexing - the total number of edge tokens\nshown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node \nindexing in Figure 3(a) the number is 25. To reduce such redundancy,\na subsequent two-step algorithm can be applied to the original edge\nindexing.\nPeriodic Entity Update and Cell Evaluation\nMany objects are continuously moving and hence index structures\nmust be regularly updated. Generally, this is done through a \ntwostep algorithm [13] that works as follows. The algorithm begins\nby updating all the corresponding indices of newly moved entities\n(the entity update step) and then computes the node structures of\nevery cell (the cell evaluation step). After one cell evaluation, the\nindexed user entities are retrieved and the computed node structure\nis delivered for every client that is associated with a user. After all\nthe cells are evaluated, the algorithm starts over.\nThe two-step algorithm can also be used for our edge indexing\nby updating the edge structures of the entities that moved during\nthe previous time period and by applying Lemma 1 during the cell\nevaluations. In addition to this adaptability, the Lemma also reveals\nanother important property of cell evaluations: either row edges or\ncolumn edges are enough to obtain all the node structures.\nLet us assume that the system maintains the row-wise edges.\nThe leftmost node structures are assumed to be obtained in \nadvance. Once we know the node structure of the leftmost cell per\nrow, we can compute that of its right-hand cell from the leftmost\nnode structure and the row-wise edges. We repeat this computation\nuntil we reach the rightmost cell. Hence, without any column-wise\nedges we can obtain all the node structures successfully. As a \nresult, we reduce the complexity of the index construction and update\nby a factor of two.\nFigure 3(c) illustrates the concept of our row-wise edge indexing\nmethod. The total number of tokens is reduced to 17 (8 ATs + 8\nDTs + 1 IT). The detailed analysis of its indexing complexity is\npresented in Section 5.\n4.4.2 Another Example\nFigure 4 illustrates how to construct edge structures from two\nnearby cells. In the figure, two row-wise adjacent cells 3 and 4\nhave two row-wise edge transitions between them, E+(3, 4), E\u00e2\u02c6\u2019(3, 4);\ntwo point entities P1, P2; and two polygonal entities R1, R2.\nAs shown in the figure, N3 indexes {P2, R1, R2} and N4 \nmaintains the indices of {P1, R2}. E+(3, 4) is obtained from \nEquation 1: N4 \u00e2\u02c6\u2019 (N3 \u00e2\u02c6\u00a9 N4) = {P1}. Similarly, E\u00e2\u02c6\u2019(3, 4) = N3 \u00e2\u02c6\u2019\nCell 3 Cell 4\nE+(3, 4)={P1}\nE_(3, 4)={P2,R1}\nP2 P1\nR2\nR1\nFigure 4: Example of edge indexing of two point entities\n{P1, P2} and two polygonal entities {R1, R2} between two\nrow-wise adjacent cells.\n(N3 \u00e2\u02c6\u00a9 N4) = {P2, R1}. If we know N3, E+(3, 4), and E\u00e2\u02c6\u2019(3, 4),\nwe can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)\u00e2\u02c6\u2019\nE\u00e2\u02c6\u2019(3, 4) = {P1, R2}.\nThe above calculation also corresponds to our intuition. P2, R1,\nR2 overlap with cell 3 while P1, R2 overlap with cell 4. When\ntransiting from cell 3 to 4, the algorithm will recognize that P2, R1\ndisappear and P1 is newly appearing while the spatial condition of\nR2 is unchanged. Thus, we can insert P2, R1 in the disappearance\nedge set and insert P1 in the appearance edge set.\nObviously, edge indexing is inefficient for indexing a point \ngeometry. Node indexing has one IT per point entity and requires\none token removal and one insertion upon any location movement.\nEdge indexing, however, requires one AT and one DT per point \nentity and two token removals and two insertions during the update,\nin the worst case. In such a situation, we take advantage of using\nboth according to the spatial property of entity extension. In \nsummary, as shown in Figure 3(c), our edge indexing method uses edge\nstructures for the AOI enabled entities (A, E1, E2) while it uses\nnode structures for the point entity (S).\n4.5 Optimization Issues\nIn this section, we describe several optimization techniques for\nedge indexing, which reduces the algorithm complexity \nsignificantly.\n4.5.1 Single-table Approach: Update\nTypically, there exist two practical policies for a region update:\nFull Update simply removes every token of the previous entity \nregion and re-inserts newly updated tokens into newly \npositioned areas.\nIncremental Update only removes the tokens whose spatial \nrelationship with the cells changed upon an update and inserts\nthem into new edge structures that satisfy the new spatial\nconditions.\n4.5.2 Two-table Approach: Separating Moving \nEntities from Stationary Entities\nSo far, we have not addressed any side-effect of token removals\nduring the update operation. Let us assume that an edge index is\nrealized with a hash table. Inserting a token is implemented by \ninserting it at the head of the corresponding hash bucket, hence the\nprocessing time becomes constant. However, the token removal\ntime depends on the expected number of tokens per hash bucket.\nTherefore, the hash implementation may suffer from a significant\nsystem penalty when used with a huge number of populated \nentities.\nTwo-table edge indexing is designed to make the token removal\noverhead constant. First, we split a single edge structure that \nindexes both stationary and moving entities into two separate edge\n406\nTable 1: Summary of notations for virtual entities and their\nproperties.\nSymbol Meaning\nU set of populated object entities\nO set of moving object entities, O \u00e2\u0160\u2020 U\nUq set of populated user entities\nQ set of moving user entities, Q \u00e2\u0160\u2020 Uq\nA set of avatars, A = {a|a \u00e2\u02c6\u02c6 U \u00e2\u02c6\u00a9 Uq}\ni.P location of entity i where i \u00e2\u02c6\u02c6 (U \u00e2\u02c6\u00aa Uq)\ni.R AOI of entity i where i \u00e2\u02c6\u02c6 (U \u00e2\u02c6\u00aa Uq)\nmi side length of entity i where i \u00e2\u02c6\u02c6 (U \u00e2\u02c6\u00aa Uq). It is\nrepresented by the number of cell units.\nm average side length of the AOI of entities\nV ar(mi) variance of random variable mi\nv maximum reachable distance. It is represented by\nthe number of cell units.\nstructures. If an entity is not moving, its tokens will be placed in a\nstationary edge structure. Otherwise, it will be placed with a \nmoving edge.\nSecond, all moving edge structures are periodically reconstructed.\nAfter the reconstruction, all grid cells are evaluated to compute\ntheir visible sets. Once all the cells are evaluated, the moving\nedges are destroyed and the reconstruction step follows. As a result,\nsearch operations on the moving edge structures are no longer \nnecessary and the system becomes insensitive to any underlying \ndistribution pattern and moving speed of the entities. A singly linked list\nimplementation is used for the moving edge structure.\n5. ANALYSIS\nWe analyze three indexing schemes quantitatively (node indexing,\nedge indexing, and two-table edge indexing) in terms of memory\nutilization and processing time. In this analysis, we assume that\nnode and edge structures are implemented with hash tables.\nFor hash table manipulations we assume three memory-access\nfunctions: token insertion, token removal, and token scan. Their\nprocessing costs are denoted by Ta, Td, and Ts, respectively. A \ntoken scan operation reads the tokens in a hash bucket sequentially. It\nis extensively used during cell evaluations. Ts and Td are a function\nof the number of tokens in the bucket while Ta is constant.\nFor the purpose of analysis, we define two random variables.\nOne variable, denoted by mo, represents the side length of the AOI\nof an entity o. The side lengths are uniformly distributed in the\nrange of [mmin, mmax]. The average value of mo is denoted by\nm. The second random variable v denotes the x-directional or \nydirectional maximum distance of a moving entity during a time \ninterval. The simulated movement of an entity during the given time\nis also uniformly distributed in the range of [0, v]. For a simple\ncalculation, both random variables are expressed as the number of\ncell units.\nTable 1 summarizes the symbolic notations and their meaning.\n5.1 Memory Requirements\nLet the token size be denoted by s. Node indexing uses s \u00c2\u00b7 |Uq|\nmemory units for user entities and s \u00c2\u00b7\n\u00c3\u02c6o\u00e2\u02c6\u02c6U (mo + 1)2\n\u00e2\u2030\u02c6 s(m2\n+\n2m + 1 + V ar(mo))|U| units for object entities. Single-table\nedge indexing consumes s \u00c2\u00b7 |Uq| storage units for the user entities\nand s \u00c2\u00b7\n\u00c3\u02c6o\u00e2\u02c6\u02c6U 2(mo + 1) \u00e2\u2030\u02c6 2s(m + 1)|U| for the object entities.\nTwo-table edge indexing occupies s \u00c2\u00b7 |Uq| units for the users and\ns{\n\u00c3\u02c6i\u00e2\u02c6\u02c6O 2(mi+1)+\n\u00c3\u02c6j\u00e2\u02c6\u02c6(U\u00e2\u02c6\u2019O) 2(mj +1)} \u00e2\u2030\u02c6 2s(m+1)|U| units\nfor the objects. Table 2 summarizes these results. In our target \napTable 2: Memory requirements of different indexing methods.\nindexing method user entities object entities\nnode indexing s \u00c2\u00b7 |Uq| s((m + 1)2\n+ V ar(mo))|U|\nsingle-table edge s \u00c2\u00b7 |Uq| 2s(m + 1)|U|\ntwo-table edge s \u00c2\u00b7 |Uq| 2s(m + 1)|U|\nplication, our edge indexing methods consume approximately m+1\n2\ntimes less memory space than node indexing.\nDifferent grid cell partitioning with edge methods will lead to\ndifferent memory requirements. For example, here are two grids:\na M \u00c3\u2014 M grid and a 2M \u00c3\u2014 2M grid. The memory requirement\nfor the user entities is unchanged because it depends only on the\ntotal number of user entities. The memory requirements for the\nobject entities are approximately 2s(m + 1)|U| in the M \u00c3\u2014 M\ngrid case and 2s(2m + 1)|U| for the (2M) \u00c3\u2014 (2M) grid. Thus, a\nfour times larger cell size will lead to an approximately two times\nsmaller number of tokens.\n5.2 Processing Cost\nIn this section, we focus on the cost analysis of update operations\nand cell evaluations. For a fair comparison of the different methods,\nwe only analyze the run-time complexity of moving objects and\nmoving users.\n5.2.1 Update Cost\nWe assume that a set of moving objects O and a set of moving\nusers Q are known in advance.\nSimilar to edge indexing, node indexing has two update \npolicies: full update and incremental update. Full update, implemented\nin Q-Index [13] and SINA [10], removes all the old tokens from\nthe old cell node structures and inserts all the new tokens into the\nnew cell nodes. The incremental update policy, implemented by no\nexisting work, removes and inserts all the tokens whose spatial \ncondition changed during a period. In this analysis, we only consider\nincremental node indexing.\nTo analyze the update cost of node indexing, we introduce the\nmaximum reachable distance (v), where the next location of a \nmoving entity, whose previous location was at cell(0,0), is uniformly\ndistributed over the (\u00c2\u00b1v, \u00c2\u00b1v) grid cell space as illustrated in \nFigure 5. We also assume that the given maximum reachable distance\nis less than any side length of the AOI of the objects in the \nsystem; that is, v < mo where o \u00e2\u02c6\u02c6 O. As seen in Figure 5, the\nnext location may fall into three categories: areas A, B, and the\ncenter cell area (0,0). If an object resides in the same cell, there\nwill be no update. If the object moves into the area A, there will\nbe (i + j)(mo + 1) \u00e2\u02c6\u2019 ij token insertions and removals, where\n1 \u00e2\u2030\u00a4 i, j \u00e2\u2030\u00a4 v. Otherwise, there will be k(mo + 1) token insertions\nand removals, where 1 \u00e2\u2030\u00a4 k \u00e2\u2030\u00a4 v. Thus, the expected \nprocessing time of an object update for node indexing is the summation of\nthree different movement types\nT\nnode\nper update(o) =\n4 \u00c2\u00b7 (A) + 4 \u00c2\u00b7 (B)\n(2v + 1)2\n\u00c2\u00b7 (Ta + Td)\n=\nv(v + 1){v(4mo + 3 \u00e2\u02c6\u2019 v) + 2(mo + 1)}\n(2v + 1)2\n\u00c2\u00b7 (Ta + Td) (3)\nand the expected processing time of any object for node indexing\nis obtained by\nT\nnode\nper update =\n\u00c3\u02c6o\u00e2\u02c6\u02c6O,v<mo\nT node\nper update(o)\n|O|\n=\nv(v + 1){v(4m + 3 \u00e2\u02c6\u2019 v) + 2m + 1)}\n(2v + 1)2\n\u00c2\u00b7 (Ta + Td) (4)\n.\n407\nTable 3: Update time cost for any single update event where v < mq, mo and q \u00e2\u02c6\u02c6 Q.\nindexing method queries \u00c3\u2014(Ta + Td) (seconds) objects \u00c3\u2014(Ta + Td) (seconds)\nnode indexing with incremental update |Q| |O| \u00c2\u00b7 v(v+1){v(4m+3\u00e2\u02c6\u2019v)+2(m+1)}\n(2v+1)2\nsingle-table edge indexing with full update |Q| |O| \u00c2\u00b7 2(m + 1)\nsingle-table edge indexing with incremental update |Q| |O| \u00c2\u00b7 v(4m(1+2v)+9v+5)\n(2v+1)2\ntwo-table edge indexing |Q| \u00c2\u00b7 Ta\nTa+Td\n|O| \u00c2\u00b7 2(m + 1) Ta\nTa+Td\nMaximum Reachable Distance (v)\n(0,0)\ni\nj\n(i,j)\nA A\nAA\nB\nB\nB\nB\nFigure 5: Illustration of next cell location, cell(i, j), of a moving\nentity whose initial location was at cell (0, 0).\nThe expected time of any single entity update for edge indexing\nwith full update is:\nT\nedgefull\nper update\n=\n\u00c3\u02c6o\u00e2\u02c6\u02c6O T\nedgefull\nper update\n(o)\n|O|\n= 2(m + 1)(Ta + Td) (5)\nThe analysis of the expected time of any single entity update for\nedge indexing with incremental update becomes complicated \nbecause the time cost depends both on the side length of the entity\nAOI and on the moving speed. Roughly speaking, its worst-case\nprocessing cost is the same as Tedgefull\nper update\n. Due to space \nlimitations we only show the analysis result of the expected processing\ntime when v of any object o \u00e2\u02c6\u02c6 O is smaller than mo:\nTedgeincremental\nper update\n=\n\u00c3\u02c6o\u00e2\u02c6\u02c6O,v<mo\nTedgeincremental\nper update\n(o)\n|O|\n=\nv(4m(1 + 2v) + 9v + 5)\n(2v + 1)2\n\u00c2\u00b7 (Ta + Td)\n=\nv(4m(1 + 2v) + 9v + 5)\n(2v + 1)2 \u00c2\u00b7 2(m + 1)\n\u00c2\u00b7 Tedgefull\nper update\n(6)\nAll update complexities are summarized in Table 3. In this \ntable, it is evident that while the update cost of the worst-case edge\nindexing (single-table edge indexing with full update policy) \ndepends only on m, that of the best-case node indexing (node \nindexing with incremental update policy) is still proportional to two \nvariables, v and m. For a smaller value of v (v = 1), the update cost\nof node indexing slightly outperforms that of edge indexing (i.e.,\n12m+8\n9\nvs. 2(m + 1)). However, as v increases, the performance\ngain is then immediately reversed (i.e., 60m+24\n25\nversus 2(m + 1),\nwhere v = 2).\nAnother interesting result is that two-table edge indexing \ndepends only on the token insertion cost, Ta. Typically, Td is slightly\n1 2 3 4 5\n0\n5\n10\n15\n20\n25\n30\n35\n40\nMaximum Reachable Distance (v) (%)\n#ofAffectedTokens\nTwo\u00e2\u02c6\u2019table Edge Indexing\nIncremental Edge Indexing\nFull Edge Indexing\nIncremental Node Indexing\nFigure 6: Simulation results of update complexity of \ndifferent indexing methods. The update complexity, the expected\nnumber of token removals and insertions per object update, is\ndrawn as a function of maximum reachable distance (v). The\naverage side length of object AOIs is 10% of the side length of\na given 2-D map.\ngreater than Ta because Td requires at least one token lookup \noperation. After the lookup, Td executes the reverse operation of Ta.\nThus, Td may well be expressed as (Ta + Tlookup) and can be \nsimplified as (Ta + |E|\n2\u00c2\u00b7b\n\u00c2\u00b7Ts) where |E| is the size of the edge structure\nand b is the number of its hash buckets. From this observation, we\ncan infer that full update of single-table edge indexing takes at least\ntwice as long as the update for two-table edge indexing.\nFigure 6 shows that full update of edge indexing when the \nmaximum reachable distance is less than the side length of any moving\nentities takes constant time to update the corresponding edge \nstructures, which mainly depends on the side length of the given AOI.\nIn this figure we assume that the average side length of the AOI is\n0.1 (or 10 %). The node indexing method, however, depends not\nonly on the side length but also on the reachable distance. Thus the\nentity update in node indexing is much heavier than the full update\nfor edge indexing.\nAs expected, these simulation results validate a common belief\nthat in less dynamic environments, incremental updates reduce the\namount of token insertions and removals noticeably while in \nextremely dynamic environments the reduction ratio becomes \nnegligible.\n5.2.2 Cell Evaluation Cost\nNode indexing scans all entities and then collects the user \nentities indexed on every cell node. Therefore, it would take |Q|\u00c3\u2014Ts to\nscan all user entities. If every node stores (m2\n+2m+1+V ar(mo))|O|\nM2\nobject entities on average, the expected completion time of one cell\nevaluation will then be\n\u00c3\u02c6o\u00e2\u02c6\u02c6O\n(m2\n+2m+1+V ar(mo))|O|\nM2 \u00c2\u00b7 Ts. If \nevery cell has at most one user entity, the expected completion time\nof all cell evaluations will be |Q| \u00c2\u00b7 (m2\n+2m+1+V ar(mo))|O|\nM2 \u00c2\u00b7 Ts.\nThe runtime complexity of the single-table cell evaluation can\n408\nTable 4: Summary of cell evaluation cost.\nindexing method expected elapsed time\nnode indexing Ts \u00c2\u00b7 |Q| \u00c2\u00b7 (m2\n+2m+1+V ar(mo))|O|\nM2\nsingle-table edge Ts \u00c2\u00b7 (|Q| + |O| \u00c2\u00b7 2(m + 1))\ntwo-table edge (Ts + Td) \u00c2\u00b7 (|Q| + |O| \u00c2\u00b7 2(m + 1))\nbe simplified as Ts \u00c2\u00b7|O|\u00c2\u00b72(m +1). In this analysis, we do not \nconsider any data delivery overhead after a cell evaluation. Note that\nin single-table edge indexing we need to scan all the tokens for cell\nevaluations. Two-table edge indexing executes in Td to remove the\nevaluated tokens after a cell evaluation. Unlike the Td operation,\nthe Td operation is much lighter because it does not require any\nlookup operation.\nTable 4 shows the expected complexities of different cell \nevaluation scenarios. If previously computed result sets are re-used \nduring the next evaluation round, the expected elapsed time of node\nindexing will be bound by the total number of cell evaluations (i.e.,\nTs(m2\n+ 2m + 1 + V ar(mo))|O|). However, in the worst case,\nthe cell evaluation of node indexing is still m+1\n2\ntimes longer than\nthat of any edge indexing method.\n5.2.3 Putting it Together: Periodic Monitoring Cost\nAs we saw in Section 5.2.1, edge indexing methods outperform\nnode indexing in terms of updates and cell evaluations. In this \nsection we focus on evaluating the performance difference between\nsingle-table edge indexing and two-table edge indexing.\nThe total elapsed time of full update based single-table edge \nindexing for a given set of moving entities is the summation of the\nelapsed time of updates and cell evaluations:\n(Ta + Td + Ts) \u00c2\u00b7 {|Q| + |O|2(m + 1)} (7)\nSimilarly, the total elapsed time of two-table edge indexing is as\nfollows:\n(Ta + Td + Ts) \u00c2\u00b7 {|Q| + |O|2(m + 1)} (8)\nFrom Equation 7 and 8 we conclude that two-table edge \nindexing, even though it represents a minor optimization of single-table\nedge indexing by replacing unpredictable Td with predictable Td,\nachieves a significant performance improvement. First of all, Td\nis very predictable and a more lightweight procedure than Td. All\nthe data structure manipulation overheads, such as Ta, Ts, and Td\ncan be easily profiled and all become constant. In addition, \ntwotable indexing is guaranteed to outperform single-table full update\nedge indexing. Another novelty of the two-table approach is that it\nis highly resilient to the underlying data distribution, regardless of\nwhether it is highly skewed or uniform.\nEquation 8 also reveals the minimum time interval that satisfies\nthe given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta,\nTs and Td are system-specific parameters, |O|, |Q|, and m are all\napplication-specific. The latter can be configured by the former\nand any given real-time constraint T. Thus, the system throughput\n- how many moving objects and users are supported by the given\nsystem - is obtained from Equation 9.\nMaximum System Throughput =\n|Q| + |O|2(m + 1) =\nT\nTs + Ta + Td\n(9)\nFor example, if a given sub-world is only filled with moving\navatars, A = Q = O, whose average side length is 10% of the\nmap side length, then Ts + Td takes 0.42 microseconds per token\nevaluation, and Ta takes 0.78 microseconds, and the system will\nhandle about 36,231 avatars per second. Every avatar can navigate\nin the sub-world freely and the same number of remotely connected\nclients receive the latest update events continuously.\n6. EVALUATION\nThis section presents two simulation setups and their performance\nresults. Section 6.1 examines whether our new view approach is\nsuperior to existing view models, in spite of its higher indexing\ncomplexity. Section 6.2 discusses the degree of practicality and\nscalability of our indexing method that is designed for our new view\nmodel.\n6.1 JustificationofObject-initiatedView Model\n6.1.1 Evaluation Metrics\nTo quantify the quality of the retrieved results of query \nprocessing, we use two widely known evaluation metrics, Precision (P)\nand Recall (R), that estimate the degree of accuracy and \ncomprehensiveness of a given result set [15]. P is the ratio of relevant, \nretrieved items to all retrieved items. A lower value of P implies that\nthe query result set contains a large number of unnecessary objects\nthat do not have to be delivered to a client. A higher P value means\na higher network traffic load than required. R is the ratio of \nrelevant, retrieved items to all relevant items. A lower R value means\nthat more objects that should be recognized are ignored. From the\nR measure, we can quantitatively estimate the occurrence of object\npopping.\nIn addition to the P and R metrics, we use a standardized \nsinglevalued query evaluation metric that combines P and R, called \nEmeasure [15]. The E-measure is defined as:\nE = 1 \u00e2\u02c6\u2019\n(\u00ce\u00b22\n+ 1)PR\n\u00ce\u00b22P + R\nwhere \u00ce\u00b2 is the relative importance of P or R. If \u00ce\u00b2 is equal to 1, P\nand R are equally important. If \u00ce\u00b2 is less than 1, P becomes more\nimportant. Otherwise, R will affect the E-measure significantly.\nA lower E-measure value implies that the tested view model has a\nhigher quality. The best E-measure value is zero, where the best\nvalues for P and R are both ones.\n6.1.2 Simulation Setup\nWe tested four query processing schemes, which use either a\nuser-initiated or an object-initiated view model:\n\u00e2\u20ac\u00a2 User-initiated visibility computation\n- RQ-OP: Region Query - Object Point\n\u00e2\u20ac\u00a2 Object-oriented visibility computation\n- PQ-OR: Point Query - Object Region\n- RQ-OR: Region Query - Object Region\n- ACQ-OR: Approximate Cell Query - Object Region\nRQ-OP is the typical computation scheme that collects all \nobjects whose location is inside a user defined AOI. PQ-OR \ncollects a set of objects whose AOI intersects with a given user point,\nformally {o|q.P \u00e2\u02c6\u02c6 o.R}. RQ-OR, an imaginary computation\nscheme, is the combination of RQ-OP and PQ-OR where the AOI\nof an object intersects with that of a user, {o|o.R \u00e2\u02c6\u00a9 q.R = \u00e2\u02c6\u2026}.\nLastly, ACQ-OR, an approximate visibility computation model, is\na special scheme designed for grid-based space partitioning, which\nis our choice of cell evaluation methodology for edge indexing. If a\nvirtual space is partitioned into tiled cells and a user point belongs\nto one of the cells, the ACQ-OR searches the objects whose AOI\n409\nTable 5: P and R computations of different visibility \ndetermination schemes.\nScheme P R\nRQ-OP |{o|o.P \u00e2\u02c6\u02c6q.R\u00e2\u02c6\u00a7q.P \u00e2\u02c6\u02c6o.R)}|\n|{o|o.P \u00e2\u02c6\u02c6q.R}|\n|{o|o.P \u00e2\u02c6\u02c6q.R\u00e2\u02c6\u00a7q.P \u00e2\u02c6\u02c6o.R)}|\n|{o|q.P \u00e2\u02c6\u02c6o.R}|\nPQ-OR |{o|q.P \u00e2\u02c6\u02c6o.R}|\n|{o|q.P \u00e2\u02c6\u02c6o.R}|\n= 1 |{o|q.P \u00e2\u02c6\u02c6o.R}|\n|{o|q.P \u00e2\u02c6\u02c6o.R}|\n= 1\nRQ-OR |{o|q.P \u00e2\u02c6\u02c6o.R}|\n|{o|q.R\u00e2\u02c6\u00a9o.R=\u00e2\u02c6\u2026}|\n|{o|q.P \u00e2\u02c6\u02c6o.R}|\n|{o|q.P \u00e2\u02c6\u02c6o.R}|\n= 1\nACQ-OR |{o|q.P \u00e2\u02c6\u02c6o.R}|\n|{o|c.R\u00e2\u02c6\u00a9o.R=\u00e2\u02c6\u2026,q.P \u00e2\u02c6\u02c6c.R}|\n|{o|q.P \u00e2\u02c6\u02c6o.R}|\n|{o|q.P \u00e2\u02c6\u02c6o.R}|\n= 1\nwould intersect with the region of the corresponding grid cell. Of\ncourse, it exhibits similar properties as RQ-OR while the result set\nof its query is not a subset of the RQ-OR query result. It identifies\nany object o satisfying the condition c.R \u00e2\u02c6\u00a9 o.R = \u00e2\u02c6\u2026 where the cell\nc satisfies q.P \u00e2\u02c6\u02c6 c.R as well.\nOur simulation program populated 100K object entities and 10K\nuser entities in a 2D unit space, [0, 1) \u00c3\u2014 [0, 1). The populated \nentities are uniformly located in the unit space. The side length of their\nAOI is also uniformly assigned in the range of [0.05, 0.14], \nmeaning 5% to 14% of the side length of the unit space. The program\nperforms intersection tests between all user and all object entities\nexhaustively and computes the P, R, and E-measure values (shown\nin Table 5).\n6.1.3 Experimental Results\nDistribution of P and R measure: Figure 7 shows the \ndistribution of P and R for RQ-OP. We can observe that P and R\nare roughly inversely proportional to each other when varying a\nuser AOI range. A smaller side length leads to higher accuracy but\nlower comprehensiveness. For example, 5% of the side length of\na user AOI detects all objects whose side length of the AOI is at\nleast 5%. Thus, every object retrieved by RQ-OP is guaranteed to\nbe all rendered at the client. But RQ-OP cannot detect the objects\noutside the AOI of the user, thus suffering from too many missing\nobjects that should be rendered. Similarly, the user whose AOI is\nwider than any other AOI cannot miss any objects that should be\nrendered, but detects too many unnecessary objects. To remove\nany object popping problem, the side length of any AOI should be\ngreater than or equal to the maximum visible distance of any object\nin the system, which may incur significant system degradation.\nE-measure Distribution: Figure 8 reveals two trends. First,\nthe precision values of RQ-OP lie in between those of ACQ-OR\n(100 \u00c3\u2014 100 grid) and RQ-OR. Second, the tendency curve of the\nPrecision-to-E-measure plot of RQ-OR shows resemblance to that\nof ACQ-OR. It looks as if the two curves lie on the same \nimaginary curve, which conveys that ACQ-OR inherits the properties of\nRQ-OR.\nEffect of Different Grid Size: Figure 9 shows the statistical\ndifference of E-measure values of seven different grid partitioning\nschemes (using ACQ-OR) and one RQ-OP model. We use a \nboxand-whisker plot to show both median values and the variances\nof E-measure distributions and the outliers of each scheme. We\nalso draw the median value of the RQ-OP E-measures (green line)\nfor comparison purposes. While the ACQ-OR schemes have some\noutliers, their E-measure values are heavily concentrated around\nthe median values, thus, they are less sensitive to object AOI. As \nexpected, fine-grained grid partitioning showed a smaller E-measure\nvalue. The RQ-OP scheme showed a wider variance of its quality\nthan other schemes, which is largely attributable to different user\nside lengths. As the R measure becomes more important, the query\nquality of ACQ-OR is improved more evidently than that of \nRQOP. From Figure 9, the 20\u00c3\u201420 grid scheme had a better E-measure\nTable 6: Measured elapsed time (seconds) of 100K moving \nobjects and 10K moving users in a slowly moving environment\n(v = 1).\nindexing Update Time Evaluation Time Total\nSingle-tableF ull\n3.48 0.82 4.30\nSingle-tableIncr\n2.08 0.80 2.88\nTwo-table 1.74 0.93 2.67\nTable 7: Measured elapsed time (seconds) of 100K moving \nobjects and 10K moving users in a highly dynamic environment\n(v = 15).\nindexing Update Time Evaluation Time Total\nSingle-tableF ull\n3.65 0.77 4.42\nSingle-tableIncr\n3.49 0.74 4.23\nTwo-table 1.75 0.93 2.68\nvalue in a prioritized environment than in an equal-prioritized \nenvironment. As a result, we can roughly anticipate that at least the\n20\u00c3\u201420 grid cell partitioning retrieves a higher quality of visible sets\nthan the RQ-OP.\n6.2 Evaluation of Edge Indexing\nIn this section, we present the preliminary results of the \nsimulations that examine the applicability of our edge indexing \nimplementation. To estimate the degree of real-time support of our \nindexing method, we used the total elapsed time of updating all moving\nentities and computing visible sets for every cell. We also \nexperimented with different grid partitioning policies and compared them\nwith exhaustive search solutions.\n6.2.1 Simulation Setup\nWe implemented edge indexing algorithms in C and ran the \nexperiments on a 64-bit 900MHz Itanium processor with 8 GBs of\nmemory. We implemented a generalized hash table mechanism to\nstore node and edge structures.\n6.2.2 Experimental Results\nPeriodic Monitoring Cost: Tables 6 and 7 show the \nperformance numbers of different edge indexing methods by varying v.\nThe moving speed of entities was also uniformly assigned between\n0 and v. In a slowly moving environment (Table 6), the incremental\nedge indexing method outperforms full update edge indexing, due\nto reduced index updates; the two-table approach surpasses the \nperformance of single-table schemes, mainly due to the lack of token\nlookup during an update. However, the two-table method showed\na slightly higher evaluation time than the two single-table methods\nbecause of its sequential token removal.\nTable 7 exemplified the elapsed time of index updates and cell\nevaluations in a highly dynamic environment where slowly \nmoving and dynamically moving objects co-exist. Compared with the\nresults shown in Table 6, the two-table approach produced similar\nperformance numbers regardless of the underlying moving \nenvironments. However, the performance gain obtained by the incremental\npolicy of the single-table is decreased compared with that in the\nslowly moving environment.\nEffect of Different Grid Size: How many object updates and\ncell evaluations can be supported in a given time period is an \nimportant performance metric to quantify system throughput. In this\nsection, we evaluate the performance results of three different \nvisibility computation models: two computation-driven exhaustive\nsearch methods; and one two-table edge indexing method with \ndifferent grid sizes.\n410\n0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1\n0\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n1\nRecall (R)\nPrecision(P) 5% Range Query\n6% Range Query\n7% Range Query\n8% Range Query\n9% Range Query\n10% Range Query\n11% Range Query\n12% Range Query\n13% Range Query\n14% Range Query\nOptimality\n0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1\n0\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n1\nPrecision (P)\nE\u00e2\u02c6\u2019measure\nOptimality\nRQ\u00e2\u02c6\u2019OP\nRQ\u00e2\u02c6\u2019OR\nACQ\u00e2\u02c6\u2019OR (100x100 grid cells)\n10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ\u00e2\u02c6\u2019OP\n0\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n1\nE\u00e2\u02c6\u2019Measure\nVisibility Test Scheme\nMedian of RQ\u00e2\u02c6\u2019OP\nFigure 7: Distribution of P and R \nmeasured by RQ-OP.\nFigure 8: E-measure value as a function of\nPrecision value P when \u00ce\u00b2 = 1.\nFigure 9: E-measure value as a function of\nACQ-QR grid partitioning scheme when\n\u00ce\u00b2 = 2.\n10K 50K 100K\n10\n\u00e2\u02c6\u20191\n10\n0\n10\n1\n10\n2\n# of Object Updates (10K queries)\nTotalElapsedTime(seconds)\nPopulation Size = 100K, visible range = 5\u00e2\u02c6\u201915%, mobility = 1%\nExhaustive Search (Intersection Test)\nExhaustive Search (Euclidean Distance Measure)\n200x200 Two\u00e2\u02c6\u2019table Edge Indexing\n100x100 Two\u00e2\u02c6\u2019table Edge Indexing\n50x50 Two\u00e2\u02c6\u2019table Edge Indexing\nFigure 10: Total elapsed time of different indexing schemes.\nExhaustive search methods do not maintain any intermediate \nresults. They simply compute whether a given user point is inside\na given object AOI. They can tolerate unpredictable behavior of\nobject movement. In spite of their simple design and \nextensibility, they suffer from lengthy computational delays to complete the\nvisibility determination. Figure 10 reveals the performance \ndifference between the exhaustive solutions and the two-table methods,\na difference of up to two orders of magnitude.\nAs shown in Section 5, the total elapsed time of object updates\nand cell evaluations is linear with respect to the average side length\nof object AOI. Because the side length is represented by cell units,\nan increase in the number of cells increases the side lengths \nproportionally. Figure 10 illustrates that the measured simulation results\nroughly match the expected performance gain computed from the\nanalysis.\n7. CONCLUSION AND FUTURE WORK\nTo support dynamic extensibility and scalability in highly dynamic\nenvironments, we proposed a new view paradigm, the object-initiated\nview model, and its efficient indexing method, edge indexing. \nCompared with the traditional view model, our new view model promises\nto eliminate any object popping problem that can easily be observed\nin existing virtual environments at the expense of increased \nindexing complexity. Our edge indexing model, however, can overcome\nsuch higher indexing complexity by indexing spatial extensions at\nedge-level not at node-level in a grid partitioned sub-world and\nwas validated through quantitative analyses and simulations.\nHowever, for now our edge indexing still retains a higher \ncomplexity, even in a two-dimensional domain. Currently, we are \ndeveloping another edge indexing method to make the indexing \ncomplexity constant. Once indexing complexity becomes constant, we\nplan to index 3D spatial extensions and multi-resolutional \ngeometry data. We expect that our edge indexing can contribute to \nsuccessful deployment of next-generation gaming environments.\n8. REFERENCES\n[1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern\ndistributed interactive application design, Tech. Rep., Department of\nComputer Science, National University of Ireland, Maynooth, Maynooth, Col.\nKildare, Ireland, 2004.\n[2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game\ntraffic analysis: An MMORPG perspective, in NOSSDAV\"05. 2005, pp.\n19-24, ACM Press.\n[3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and\nYanghee Choi, Traffic charateristics of a massively multiplayer online role\nplaying game and its implications, in NetGames \"05, Oct 2005.\n[4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds\nwith grid computing and streaming, Gamastutra Magazine,\nhttp://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml,\nSeptember 2003.\n[5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote\nwalkthroughs., Comput. Graph. Forum, vol. 20, no. 3, 2001.\n[6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote\nrendering, in Second International Workshop on Distributed Interactive\nSimulation and Real-Time Applications, 1998.\n[7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for\ninteractive frame rates during visualization of complex virtual environments,\nin SIGGRAPH \"93, New York, NY, USA, 1993, pp. 247-254, ACM Press.\n[8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for\nlocation-based services, in WWW \"03, New York, NY, USA, 2003, pp.\n112-117, ACM Press.\n[9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates\nin r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003.\n[10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable\nincremental processing of continuous queries in spatio-temporal databases, in\nACM SIGMOD \"04. 2004, pp. 623-634, ACM Press.\n[11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main\nmemory evaluation of monitoring queries over moving objects, Distrib.\nParallel Databases, vol. 15, no. 2, pp. 117-135, 2004.\n[12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for\nmonitoring continuous spatial queries over moving objects., in SIGMOD\nConference, 2005.\n[13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query\nindexing and velocity constrained indexing: Scalable techniques for\ncontinuous queries on moving objects, IEEE Transactions on Computers, vol.\n51, no. 10, pp. 1124-1140, Oct. 2002.\n[14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object\ndatabases, in DASFAA \"03, Washington, DC, USA, 2003, p. 175, IEEE\nComputer Society.\n[15] C. J. Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer\nScience, University of Glasgow, 1979.\n411\n": ["edge indexing", "dynamic virtual environment", "game-based application", "mutable virtual content", "spatial database", "spatial indexing method", "real-time visibility test", "object-initiated view model", "object popping", "3d spatial extension", "3d object stream", "object pop problem", "spatial index", "visibility model", ""]}