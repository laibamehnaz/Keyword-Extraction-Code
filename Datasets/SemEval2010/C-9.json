{"EDAS: Providing an Environment for Decentralized\nAdaptive Services\nR\u00c3\u00bcdiger Kapitza\nDept. of Comp. Sciences, Informatik 4\nUniversity of Erlangen-N\u00c3\u00bcrnberg\nrrkapitz@cs.fau.de\nFranz J. Hauck\nDistributed Systems Laboratory\nUniversity of Ulm\nfranz.hauck@uni-ulm.de\nABSTRACT\nAs the idea of virtualisation of compute power, storage and\nbandwidth becomes more and more important, grid \ncomputing evolves and is applied to a rising number of applications.\nThe environment for decentralized adaptive services (EDAS)\nprovides a grid-like infrastructure for user-accessed, \nlongterm services (e.g. webserver, source-code repository etc.).\nIt aims at supporting the autonomous execution and \nevolution of services in terms of scalability and resource-aware\ndistribution. EDAS offers flexible service models based on\ndistributed mobile objects ranging from a traditional \nclientserver scenario to a fully peer-to-peer based approach. \nAutomatic, dynamic resource management allows optimized use\nof available resources while minimizing the administrative\ncomplexity.\nCategories and Subject Descriptors\nC.2.4 [Computer Communication Networks]: Distributed\nSystems-Distributed applications; D.2.12b [Software]: \nSoftware Engineering Interoperability[Distributed objects]\nGeneral Terms\nDesign, Management\n1. INTRODUCTION\nInfrastructures for grid computing aim at virtualizing a\ngroup of computers, servers, and storage as one large \ncomputing system. Resource management is a key issue in such\nsystems, needed for an efficient and automated distribution\nof tasks on the grid. Such grid infrastructures are often \ndeployed at enterprise level, but projects like SETI@home [1]\nhave demonstrated the feasibility of more decentralized grids\nas well. Current grid computing infrastructures don\"t \nprovide sufficient support for the execution of distributed, \nuseraccessed, long-term services as they are designed to solve\ncompute- or data-intensive tasks with a more or less fixed\nset of parameters. The common three-phase approach of\nresource discovery, system selection and job execution fails\nfor services that change their resource demand over time\ndue to interactive user access and run for a long period of\ntime. Instead an infrastructure for long-term services has\nto place services based on their current demand and their\nestimated future requirements. If the distribution turns out\nto be wrong (e.g. a node gets overloaded) the service has to\nbe migrated within the grid (e.g. to a more powerful and\nless loaded node). Migration however is expensive as the\nwhole state of a service has to be transfered. Additionally\na non-replicated service is not accessible during migration.\nTherefore the resource management has to avoid migration\nif possible. Furthermore a service concept has to be \nprovided that evades overload in the first place, and secondly\ninhibits service unavailability if migration can\"t be avoided.\nEDAS [2] aims at providing a grid-like infrastructure for\nuser-accessed, long-term services that allows the dynamic\nadaptation at run-time, provides a management \ninfrastructure, and offers system-level support for scalability and fault\ntolerance. Nodes can dynamically join and leave the \ninfrastructure, and all management tasks, especially the resource\nmanagement, are decentralized. The environment is built\nupon our AspectIX [3] middleware infrastructure, which \ndirectly supports QoS-based, dynamic reconfiguration of \nservices.\nThe resource management focuses on the execution of \nservices that have a long, potentially infinite, operating time.\nTheses services are organized in projects. Each project has\na distributed execution scope called a service environment.\nSuch an environment possibly spans multiple institutions.\nEach institution represents an administrative domain that\ncan support a project with a fixed set of resources. Our\napproach supports the adaptive resource management of all\nprojects in scope of an institution based on an algorithm\ninspired by the diffusive algorithms for decentralized \nloadbalancing [4]. It is not known how to optimally subdivide\nthese resources for the services as the resource demand of\nservices can change over time or even frequently fluctuate.\nTo provide resources as needed, our approach automatically\nrededicates evenly free or not needed resources between \nservice instances across projects and nodes. The whole process\nArticle 5\nof rededication is scalable as it is decentralized and respects\ncertain limits like the physically available resources of a node\nand the amount of resources dedicated to a project. In cases\nwhere rededication is not possible, the migration of the \ndemanding service is initiated.\nEDAS further supports flexible service models, including a\nfully centralized client/server structure, completely \npeer-topeer based systems, and various configurations in between\nthat allow a controlled use of peer resources based on the\nfragmented object model [5]. The overall goal is to provide\na generic service architecture that allows to implement the\nservice functionality once, and then, ideally, run this \nservice with different service models and adapt it at run-time,\nthereby scaling from a single user local instance to a \nmultidomain-spanning scalable service.\nTo reduce the implementation effort of such services a\nframework has been developed that supports the run-time\nevolution from a traditional client/server scenario to an \nactive replicated server with clients interacting in a hybrid\npeer-to-peer architecture as known from Napster. In a \nlongterm-service grid infrastructure, active replication has \nvarious benefits: Replicas can join and leave the object group\nand therefore replicas can be migrated without service \nunavailability. Load of non-modifying requests can be evenly\ndistributed across the replicas making overload situations\nless likely. Finally a certain amount of node crashes can be\ntolerated.\nThe following section describes the used features of \nAspectIX followed by a brief overview of the core components\nand concepts of EDAS. Section 4 explains the self-managing\nand rededication concepts of distributed adaptive resource\nmanagement. Section 5 describes the framework for \ndecentralized adaptive services. Section 6 describes related work\nand finally Section 7 concludes the paper.\n2. BASIC MIDDLEWARE\nThe EDAS environment is based on the AspectIX \nmiddleware. At its core, it provides a CORBA-compliant ORB\nand, as such, supports heterogeneous distributed systems.\nFurthermore AspectIX supports the fragmented object model\n[5] that is used to implement and provide decentralized \nadaptive services.\nIn the fragmented object model, the distinction between\nclient stubs and the server object is no longer present (Fig.\n1). From an abstract point of view, a fragmented object is\na unit with unique identity, interface, behavior, and state,\nlike in classic object-oriented design. The implementation of\nthese properties however is not bound to a specific location,\nbut may be distributed arbitrarily on various fragments.\nAny client that wants to access the fragmented object needs\na local fragment, which provides an interface identical to\nthat of a traditional stub. However internal distribution and\ninteraction is not only transparent on the outer interface of\nthe distributed object, but may even change dynamically at\nruntime. This allows the fragmented object model to adapt\nto changing environment conditions or quality of service \nrequirements. It offers to change the service model on \ndemand from traditional client-server to a peer-to-peer based\napproach and all kind of intermediate stages by migration\nand exchanging of fragments.\n3. EDAS CORE COMPONENTS\nFigure 1: Fragmented object on three nodes\nEDAS has three major components: Every node that \nactively supports decentralized adaptive services provides a\nhome environment. The home environment basically \nmanages resources of one or more nodes belonging to the same\nadministrative domain or institution. The service \nenvironment is spread over a set of domains that support a certain\nproject and relies on basic services from the corresponding\nhome environments. The service environment supports the\nexecution of services belonging to the same project. Finally,\nthe decentralized adaptive service is dynamically distributed\nwithin the scope of an associated service environment.\nThe home environment has the role of a mediator between\nthe nodes of an institution and one or more service \nenvironments, each running a set of services. Fig. 2 shows three\ndomains each running a home environment that spans all\nnodes of the respective domains. Every node provides a set\nof resources. Each domain has a manager who can use that\nhome environment to assign resources to service \nenvironments and to revoke them. Apart from providing system\nload and all kinds of resource-usage information to the \nservice environment, the home environment also notifies about\nall important system events like a node shutdown or crash.\nA service environment represents a scope of distribution\nfor one or more services. Usually, a service environment is\nowned by one organization or community and dedicated to\none project. A service manager can start, stop, and \nconfigure services through the interface of the service environment\nand decides which resources provided by home environments\nare accepted.\nIn most cases a service environment is spread over more\nthan one administrative domain as shown in Fig. 2. One\nof the main tasks of the service environment is to support\nthe migration of services or service components especially\nbetween different home environments. The service \nenvironment thereby takes available resources, the requirements of\nthe services, and the policies provided by the service \nmanager into account. The migration of service components can\nbe necessary for various reasons, like node shutdown, \nresource constraints, and the growth or shrinkage of a service\nenvironment.\n4. DECENTRALIZED \nRESOURCEMANAGEMENT\nResource management for long-term services has other \nrequirements than resource management in common grid \ncomputing environments. For instance even in the context of\ntraditional grid systems it is very difficult to determine or\neven only estimate the resource requirements of a task [6].\nFor long-term services this is even harder, and it is likely\nthat the resource demand frequently changes. This turns\nArticle 5\nHost FHost D Host E\nHost A Host C\nService Environment\nService B\nService A\nHome Env.\nHome Environment\nHome Environment\nBoundary of the fragmented object\nService Manager\nDomain Manager\nDomain Manager\nFigure 2: EDAS Scenario\nthe optimal distribution of services over a set of nodes into\na difficult problem. In general the migration of services is a\nprerequisite of EDAS as it offers a solution if the initial \ndistribution decision was wrong (e.g. initial start of previously\nunknown service) or the demand of services has changed\nsubstantially. But migration is costly, since the whole state\nof a service possibly including program code has to be \ntransfered. If the service is not replicated it will be unavailable\nduring migration. Taking this into account a resource \nmanagement should place services and adaptively rededicate \nresources between services and nodes as needed to prevent\nmigration. As EDAS aims at providing a grid-like \ninfrastructure for a large set of nodes that can join and leave the\nsystem all resource management tasks have to be \ndecentralized to be scalable and should not require global knowledge.\nThe resource management can be structured into the \nfollowing different tasks:\n\u00e2\u20ac\u00a2 Adding and changing the assigned resources of a \nservice environment\n\u00e2\u20ac\u00a2 Automatic placement of service at startup time and\nduring migration due to overload\n\u00e2\u20ac\u00a2 Keeping all kind of resource limits, especially the limits\nof service environments\n\u00e2\u20ac\u00a2 Compensate leaving and crashed nodes\nIn the next sections we will describe what kind of resource\nlimits there are and how to do resource management based\non these basic conditions.\n4.1 Resource Limits\nOur approach manages resources on two stages, the node\nlevel and the service-environment level. At the node level\nwe monitor usage of all kind of physical resources like disk\nspace, memory, CPU and network bandwidth but also \nlogical ones like open files, sockets and threads. The entity of\nmonitoring is a service or a service component in case of a\ndecentralized adaptive service. Every service has so called\nlocal limits that restrict the resource usage in context of the\ncurrent node. If a service runs the risk of exceeding such a\nlocal limit the home environment tries to extend the limits\nor notifies the responsible service environment if \nrededication is not possible. Reaching a local limit can be caused\nby two reasons: an overloaded node or an overloaded \nservice environment. In the first case service migration might\nhelp, in the second case migration to another administrative\ndomain might be an option, or simply reducing resource \ndemand by stopping the service. Of course there could be more\nthan one service of the same service environment at a node.\nTherefore the assigned resources of a service environment\nat a node can be easily computed by summing up all local\nlimits of its services.\nFurthermore each node has node limits that restrict the\noverall usage of certain resources. A node limit must never\nexceed the physical resource (e.g. disk space) of a node\nand might be much smaller, e.g., for supporting local users.\nThe sum of all local limits at a node must never exceed the\nnode limit of a resource. Therefore observing and controlling\nthe local limits will keep the node limits and preventing\noverload.\nNodeLimitNode \u00e2\u2030\u00a5\nnumberOfLocalLimitsNodeX\ni=1\nLocalLimiti\nAt the institution level the resource usage of a service \nenvironment and its associated services is also restricted by\nso-called global limits. These limits determine the maximum\nresource usage of a project in scope of a home environment.\nThe sum of all local limits on all nodes of the institution for\na certain project therefore never exceeds its global limit.\nGlobaleLimitSE \u00e2\u2030\u00a5\nnumberOfLocalLimitsSEX\ni=1\nLocalLimiti\n4.2 Adaptive Resource Rededication\nWe start with a straight-forward implementation to \ndescribe the principal workflow. Then we propose an approach\nfor a more efficient solution and discuss its problems.\nIf a new project should be supported by a home \nenvironment it is first necessary to identify the nodes that offer\nsufficient unassigned resources to start a service. This can\nbe achieved in a naive implementation by using a flooding\napproach like it is done by the Gnutella protocol assuming\nthe nodes are connected in a random graph. These resources\nthen can be assigned to the service environment of the new\nproject which further on can start services on these nodes.\nOf course a home environment supports usually numerous\nprojects. Each of these projects has resource shares on \nvarious nodes, some of them occupied by services, other free\nand unused.\nAs the resource demand of a service changes it might be\npossible that a service reaches its local limit if the service\nis under high demand. What happens next depends on the\noverall resource usage of the service environment and the\nresource consumption at the local node. If the service \nenvironment has not reached its global limit and the node is not\noverloaded the dependent local limit of the service should be\nextended simply by reducing a local limit at another node\nof the same service environment. When all resources of the\nnode are assigned to other service environments there are\ntwo possibilities. All resources are used by services, so we\nhave to migrate a service, or the resources are assigned but\nnot used. In the later case we shall rededicate resources and\nassign them to the demanding service environment. Finally\nthe service environment might have reached its global limit.\nIn this case the resource consumption has to be reduced \neither by migrating the service to another domain and its \ndepended home environment or simply by bounding resource\nusage and if this is not possible, stopping the service.\nIn contrary to the setup of a new service environment\nwhich is not time critical and a less frequent task the \nadaptation of local limits occurs frequently and needs to be done\nArticle 5\nalmost immediately. Thus it is not an option to use \nbroadcast searches for rededication. Instead a more efficient \napproach with a bounded complexity is necessary. The same\napplies for detecting if a global limit is reached by a service\nenvironment.\nCurrently we investigate if this can be achieved by \nusing a diffusive algorithm[4] like it is used for decentralized\nload balancing. Thereby all nodes of a system are \npartitioned in groups that overlap partially. The union of all\ngroups achieves a full coverage. Group members frequently\nexchange load information and balance the load by \nmigration.\nIn our case we aim not at balancing the load but the\namount of available free resources of a service environment.\nEach node that supports a certain service environment is\nat least connected to another node that supports the same\nproject. This way it always should be known if a service \nenvironment has still enough resources and therefore if a \nservice can grow. There still remain open issues like if the \ndiffusively balanced free resources should be tightly connected to\nthe real resources, comparable to reservations. In this case\nthere might be problems if a node supports several service\nenvironments which all have services running at the node\nand a node limit is exceeded which would require service\nmigration. In fact it can be needless as the services might\nnot use all the assigned resources but the diffusive algorithm\ncaused the limit overrun by equally balancing the free \nresources of all supported service environments. If we remove\nthe mapping between free resources and real resources of a\nnode we can evade these situations. However it gets more\ncomplicated to determine the free and unassigned resources\nof a home environment.\n4.3 Placement of Services\nIndependent of the mapping of free resources the \nplacement of a service is, as already stated, a difficult problem.\nDistributing the services equally over all nodes would surely\nprevent migration in the average case even if resource \ndemand of services changes. However if the resource demand\nof services varies highly and the grid is clogged by many\nprojects it might be that a service can\"t be placed because\nthe free resources are too scattered.\nA different approach would be to consider it as an variant\nof the bin-packing problem that aims at packing items in\nbins by optimizing the number of used bins. In our case\nwe need an online approach as the items are not known\nin advance and we have a multi-dimensional problem since\na service has various resource requirements. The number\nof bins is bounded as we have a finite number of nodes in\nour grid. An algorithm for this problem has recently been\nproposed by Epstein and van Stee in [7].\nOn the downside this algorithm needs to know all nodes\nand their actual usage. As the placement of a service is not a\ntime critical problem again a flooding based approach might\noffer a solution. To reduce the number of answers only nodes\nthat provide sufficient resources need to reply. It has also\nto be considered to transform the algorithm to a distributed\none. Another problem might be that the algorithm \noptimizes the occupancy too strong. Therefore demand changes\nof service can lead to overloaded nodes and causing \nmigration. We believe this can be prevented by not only \nconsidering the actual resource consumption to determine the \nresource demand of a service but taking the previous demand\ninto account.\n5. DECENTRALIZED ADAPTIVE SERVICE\nMODEL\nIn EDAS a decentralized, adaptive service normally matches\na traditional service accessed by users like a web server, an\ninstant messaging server or a source code repository. Such\na service is represented by a fragmented object. This object\nexpands or shrinks in the scope spanned by the associated\nservice environment depending on the service demands and\nfor fault-tolerance reasons. Usually every part of the object\nis mobile and can be migrated if necessary. Each service\nhas at least two interfaces: one for management tasks and\nanother service specific for the end user. The management\ninterface offers methods to start, stop, and configure service\ninstances.\nAs this set of features requires an enormous \nimplementation effort to do it anew for each service implementation\nwe support the development of decentralized adaptive \nservices through a framework and an extended version of IDL\nin combination with a special IDL-compiler [8]. The core\nidea is to develop a service in usual client/server fashion as\nit is done in plain CORBA. This service then can be started\nand executed on the grid as a common servant. \nAdditionally it should be possible to migrate the service. This can be\nachieved by using value type based approach to describe the\nservice state as done in [9] or using the language supplied\nserialization mechanisms.\nAs we would like to tolerate node crashes and the service\nshould be available during migration we support the active\nreplication of the service. This is achieved by generating\nspecial client-side stubs that communicate with one of the\nreplicas. To keep the connection between clients and the\nreplicated object we use time-bounded references [10] that\nrestrict the migration but make the usage of location services\n(to cope with outdate references) obsolete. The replicas are\nsynchronized via a group communication framework.\nThe IDL extension consists of additional modifiers that\naffect code generation for client and server side. These\nare retain to mark non-modifying operations which allows\nfaster responses and load balancing of those requests. \nFurthermore one can mark methods as local which indicates\nthat they can be locally processed. In this case the \nIDLcompiler creates placeholder for local execution. Apart form\nmethods that are usual static this is useful to implement\nclient-side contribution and interaction. For example if a\nclient-stub offers a method which results in a file transfer\nit is possible to integrate a custom protocol that forwards\na modified request to the replicated object which returns\nnot the file as in the common case but URLs that point to\nclients that previously requested the file. Now the \nclientstub fetches the data from the offered location and responds\nas if it was supplied by the server object. This peer-to-peer\nbased behavior as known from Napster is transparent to the\nclient and can be switched on and off depending on \nenvironment conditions like load and community as needed. Finally\nwe provide another modifier to mark administrative \noperations. If a method is marked with admin an authentication\nis necessary. The method to authenticate is pluggable and\nmight be by pass-phrase, internet address or any other \nauthentication scheme. This modifier facilitates the creation\nof service management methods.\nArticle 5\n6. RELATED WORK\nGrid infrastructures like the Globus-Toolkit [11] provide\nservices and mechanisms for distributed heterogeneous \nenvironments to combine resources on demand to solve resource\nconsuming and compute intensive tasks. Due to this \norientation they focus on different service models, provide no\nsupport for object mobility if even supporting a distributed\nobject approach at all. But most important they follow a\ndifferent resource management approach as they target the\nparallel execution of a large number of short and midterm\ntasks.\nJavaSymphony [12] and Ibis [13] provide object mobility\nbut are limited to the Java programming language and focus\non object oriented high performance computing.\nActively replicated objects are provided by Jgroup [14]\nbased on RMI. On top of this basic middleware a replication\nmanagement layer has been implemented called ARM [15].\nJGroup focus on the active replication of objects but lacks\nsupport for more flexible services like EDAS does. ARM\ncan be compared to EDAS but supports no resource aware\ndistribution.\nFog [16] and Globe [17] are basic middleware environments\nthat support the fragmented object approach. Globe \nconsiders replication and caching. Both systems lack support\nfor resource aware distribution.\n7. CONCLUSION AND ONGOING WORK\nBased on the fragmented object model and the \narchitecture of the EDAS environment, decentralized adaptive \nservices can be easily designed, implemented and executed.\nAs described the resource management can be \ndecomposed in two main problems that have to be solved. \nControlling and managing of resource limits including ensuring\nthat the assigned resources are available (even in the context\nof node crashes) and the autonomous placement of services.\nFor both problems we offer a solution, a currently \nimplemented simulation environment will verify their feasibility.\nIn a next step the resource management will be integrate\nin an already implemented prototype of the EDAS \narchitecture.\nAs described we have already an early implementation of\nthe framework for the decentralized adaptive services. This\nframework has to be extended to smoothly interact with\nthe resource management and the EDAS architecture. In a\nfinal step we need to implement some services that verify\nthe usability of the whole EDAS project.\n8. REFERENCES\n[1] D. Werthimer S. Bowyer J. Cobb D. Gedye\nD. Anderson W. T. Sullivan, III. A new major seti\nproject based on project serendip data and 100,000\npersonal computers. In Proc. of the Fifth Intl. Conf.\non Bioastronomy, 1997.\n[2] Hans Reiser R\u00c2\u00a8udiger Kapitza, Franz J. Hauck.\nDecentralized, Adaptive Services: The AspectIX\nApproach for a Flexible and Secure Grid Environment.\nIn Grid Services Engineering and Management\n(GSEM 2004), Erfurt, Germany, 2004. Springer.\n[3] Hans P. Reiser, Franz J. Hauck, R\u00c2\u00a8udiger Kapitza, and\nAndreas I. Schmied. Integrating fragmented objects\ninto a CORBA environment. In Proc. of the\nNet.ObjectDays, 2003.\n[4] Tiberiu Rotaru and Hans-Heinrich N\u00c2\u00a8ageli. Dynamic\nload balancing by diffusion in heterogeneous systems.\nJ. Parallel Distrib. Comput., 64(4):481-497, 2004.\n[5] M. Makpangou, Y. Gourhant, J.-P. Narzul, and\nM. Shapiro. Fragmented objects for distributed\nabstractions.\n[6] Jennifer M. Schopf. Ten actions when grid scheduling:\nthe user as a grid scheduler. pages 15-23, 2004.\n[7] Leah Epstein and Rob van Stee. Optimal online\nbounded space multidimensional packing. In SODA\n\"04: Proceedings of the fifteenth annual ACM-SIAM\nsymposium on Discrete algorithms, pages 214-223,\nPhiladelphia, PA, USA, 2004. Society for Industrial\nand Applied Mathematics.\n[8] Hans P. Reiser, Martin Steckermeier, and Franz J.\nHauck. IDLflex: a flexible and generic compiler for\nCORBA IDL. In Proc. of the Net.ObjectDays (Erfurt,\nGermany, Sep. 10-13, 2001), 2001.\n[9] R\u00c2\u00a8udiger Kapitza, Holger Schmidt, and Franz J.\nHauck. Platform-independent object migration in\nCORBA. In Proc. of the OTM\"05 Conferences (DOA,\nAgia Napa, Cyprus, Oct 31-Nov. 04, 2005), 2005.\n[10] R\u00c2\u00a8udiger Kapitza, Hans P. Reiser, and Franz J. Hauck.\nStable, time-bound references in context of\ndynamically changing environments. In MDC\"05:\nProc. of the 25th IEEE Int. Conf. on Distributed\nComputing Systems - Workshops (ICDCS 2005\nWorkshops), 2005.\n[11] Ian Foster, Carl Kesselman, and Steven Tuecke. The\nanatomy of the Grid: Enabling scalable virtual\norganizations. Lecture Notes in Computer Science,\n2150, 2001.\n[12] Thomas Fahringer and Alexandru Jugravu.\nJavasymphony: new directives to control and\nsynchronize locality, parallelism, and load balancing\nfor cluster and grid-computing. In JGI \"02:\nProceedings of the 2002 joint ACM-ISCOPE\nconference on Java Grande, pages 8-17, New York,\nNY, USA, 2002. ACM Press.\n[13] Rob V. van Nieuwpoort, Jason Maassen, Rutger\nHofman, Thilo Kielmann, and Henri E. Bal. Ibis: an\nefficient java-based grid programming environment. In\nJGI \"02: Proceedings of the 2002 joint ACM-ISCOPE\nconference on Java Grande, pages 18-27, New York,\nNY, USA, 2002. ACM Press.\n[14] Alberto Montresor, Renzo Davoli, and Ozalp\nBabaoglu. Middleware for dependable network\nservices in partitionable distributed systems. SIGOPS\nOper. Syst. Rev., 35(1):73-96, 2001.\n[15] H. Meling and B. Helvik. Arm: Autonomous\nreplication management in jgroup, 2001.\n[16] Mesaac Makpangou, Yvon Gourhant, Jean-Pierre\nLe Narzul, and Marc Shapiro. Fragmented objects for\ndistributed abstractions. In Readings in Distributed\nComputing Systems.\n[17] Philip Homburg, Leendert van Doorn, Maarten van\nSteen, Andrew S. Tanenbaum, and Wiebren de Jonge.\nAn object model for flexible distributed systems. In\nProceedings of the 1st Annual ASCI Conference, pages\n69-78, 1995.\nArticle 5\n": ["decentralized adaptive service", "resource management", "home environment", "infrastructure", "client", "long-term service", "eda", "local limit", "global limit", "resource", "node", "grid computing", "fragment object", "adaptability", ""]}